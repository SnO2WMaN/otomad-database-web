directive @auth(scopes: [String!]) on FIELD_DEFINITION

input AddMylistToMylistGroupInput {
  groupId: ID!
  mylistId: ID!
}

type AddMylistToMylistGroupPayload {
  inclusion: MylistGroupMylistInclusion!
}

enum AddSemitagToVideoFailedMessage {
  """すでに同名の仮タグが付いている"""
  ALREADY_ATTACHED

  """すでにこの仮タグはチェックした"""
  ALREADY_CHECKED
  FORBIDDEN
  INVALID_VIDEO_ID
  UNKNOWN
  VIDEO_NOT_FOUND
}

type AddSemitagToVideoFailedPayload {
  message: AddSemitagToVideoFailedMessage!
}

input AddSemitagToVideoInput {
  name: String!
  videoId: ID!
}

union AddSemitagToVideoPayload = AddSemitagToVideoFailedPayload | AddSemitagToVideoSucceededPayload

type AddSemitagToVideoSucceededPayload {
  semitag: Semitag!
}

enum AddTagToVideoFailedMessage {
  FORBIDDEN
  INVALID_TAG_ID
  INVALID_VIDEO_ID

  """原因不明のエラー"""
  UNKNOWN
  VIDEO_ALREADY_TAGGED
}

type AddTagToVideoFailedPayload {
  message: AddTagToVideoFailedMessage!
}

input AddTagToVideoInput {
  tagId: ID!
  videoId: ID!
}

union AddTagToVideoPayload = AddTagToVideoFailedPayload | AddTagToVideoSucceededPayload

type AddTagToVideoSucceededPayload {
  tag: Tag!
  video: Video!
}

type AddVideoToMylistAlreadyRegisteredError {
  registration: MylistRegistration!
}

input AddVideoToMylistInput {
  mylistId: ID!
  note: String
  videoId: ID!
}

enum AddVideoToMylistOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type AddVideoToMylistOtherErrorsFallback {
  message: AddVideoToMylistOtherErrorMessage!
}

union AddVideoToMylistReturnUnion = AddVideoToMylistAlreadyRegisteredError | AddVideoToMylistOtherErrorsFallback | AddVideoToMylistSucceededPayload | MutationInvalidMylistIdError | MutationInvalidVideoIdError | MutationMylistNotFoundError | MutationVideoNotFoundError | MutationWrongMylistHolderError

type AddVideoToMylistSucceededPayload {
  registration: MylistRegistration!
}

type BilibiliMADSource implements Node & VideoSource {
  embedUrl: String!
  events(after: String, before: String, first: Int, last: Int, orderBy: BilibiliMADSourceEventsOrderBy!): BilibiliMADSourceEventConnection!
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type BilibiliMADSourceCreateEvent implements BilibiliMADSourceEvent & Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: BilibiliMADSource!
  user: User!
}

interface BilibiliMADSourceEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: BilibiliMADSource!
  user: User!
}

type BilibiliMADSourceEventConnection {
  edges: [BilibiliMADSourceEventEdge!]!
  nodes: [BilibiliMADSourceEvent!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type BilibiliMADSourceEventEdge {
  cursor: String!
  node: BilibiliMADSourceEvent!
}

input BilibiliMADSourceEventsOrderBy {
  createdAt: SortOrder
}

type BilibiliOriginalSource {
  originalThumbnailUrl: String!
  sourceId: String!
  tags: [BilibiliOriginalSourceTag!]!
  thumbnailUrl(scale: FetchExternalSourceThumbnailScale! = LARGE): String!
  title: String!
  url: String!
}

type BilibiliOriginalSourceTag {
  name: String!
  searchTags(input: BilibiliOriginalSourceTagSearchTagsInput!): BilibiliOriginalSourceTagSearchTagsPayload!
}

input BilibiliOriginalSourceTagSearchTagsInput {
  limit: Int! = 3
  skip: Int! = 0
}

type BilibiliOriginalSourceTagSearchTagsPayload {
  items: [TagSearchItemByName!]!
}

input CalcMadCountGrowthInput {
  """終了日時"""
  end: DateTime!

  """何分割するか"""
  split: Int!

  """開始日時"""
  start: DateTime!
}

input ChangeMylistShareRangeInput {
  mylistId: ID!
  range: MylistShareRange!
}

enum ChangeMylistShareRangeOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type ChangeMylistShareRangeOtherErrorsFallback {
  message: ChangeMylistShareRangeOtherErrorMessage!
}

type ChangeMylistShareRangeSucceededPayload {
  mylist: Mylist!
}

union ChangeMylistShareReturnUnion = ChangeMylistShareRangeOtherErrorsFallback | ChangeMylistShareRangeSucceededPayload | MutationInvalidMylistIdError | MutationMylistNotFoundError | MutationWrongMylistHolderError

type ChangeUserDisplayNameInvalidNameError {
  name: String!
}

union ChangeUserDisplayNameReturnUnion = ChangeUserDisplayNameInvalidNameError | ChangeUserDisplayNameSucceededPayload

type ChangeUserDisplayNameSucceededPayload {
  user: User!
}

input CreateMylistGroupInput {
  title: String!
}

type CreateMylistGroupPayload {
  group: MylistGroup!
}

input CreateMylistInput {
  range: MylistShareRange!

  """URLなどで使う簡単な識別子"""
  slug: String!
  title: String!
}

enum CreateMylistOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type CreateMylistOtherErrorsFallback {
  message: CreateMylistOtherErrorMessage!
}

union CreateMylistReturnUnion = CreateMylistOtherErrorsFallback | CreateMylistSucceededPayload

type CreateMylistSucceededPayload {
  mylist: Mylist!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

interface Event implements Node {
  createdAt: DateTime!
  id: ID!

  """createdAtでのソートが不可能なので，別のEvent同士を混合してソートする際に必要．"""
  series: String!
  user: User!
}

"""その他のエラー"""
type ExplicitizeTagAlreadyExplicitError {
  already: TagParent!
}

enum ExplicitizeTagOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type ExplicitizeTagOtherErrorsFallback {
  message: ExplicitizeTagOtherErrorMessage!
}

input ExplicitizeTagParentInput {
  """親子関係のID"""
  relationId: ID!
}

union ExplicitizeTagParentReturnUnion = ExplicitizeTagAlreadyExplicitError | ExplicitizeTagOtherErrorsFallback | ExplicitizeTagSucceededPayload | MutationInvalidTagParentIdError | MutationTagParentNotFoundError

type ExplicitizeTagSucceededPayload {
  relation: TagParent!
}

input FetchBilibiliInput {
  """Bilibili動画の動画ID．bvid(ex:`BV1xx411c7mu`)を入力すること．"""
  bvid: String!
}

type FetchBilibiliPayload {
  source: BilibiliOriginalSource
}

enum FetchExternalSourceThumbnailScale {
  """960 x 700"""
  LARGE

  """720 x 400"""
  OGP
}

input FetchNicovideoInput {
  """ニコニコ動画の動画ID（sm2057168など）"""
  sourceId: String!
}

type FetchNicovideoPayload {
  source: NicovideoOriginalSource
}

input FetchSoundcloudInput {
  """SoundCloudのURL"""
  url: String!
}

type FetchSoundcloudPayload {
  source: SoundcloudOriginalSource
}

input FetchYoutubeInput {
  """Youtubeの動画ID（Q16KpquGsIcなど）"""
  sourceId: String!
}

type FetchYoutubePayload {
  source: YoutubeOriginalSource
}

input FindBilibiliMADSourceInput {
  sourceId: String
}

input FindMadsByOffsetInput {
  offset: Int!
  orderBy: FindMadsByOffsetInputOrderBy! = {createdAt: DESC}
  take: Int!
}

input FindMadsByOffsetInputOrderBy {
  createdAt: SortOrder
}

type FindMadsByOffsetPayload {
  hasMore: Boolean!
  nodes: [Video!]!
  totalCount: Int!
}

input FindMylistInput {
  pair: FindMylistInputHolderNameMylistSlugPair!
}

input FindMylistInputHolderNameMylistSlugPair {
  holderName: String!
  mylistSlug: String!
}

input FindNicovideoRegistrationRequestInput {
  id: ID
  sourceId: String
}

input FindNicovideoRegistrationRequestsOrderBy {
  createdAt: SortOrder
}

input FindNicovideoVideoSourceInput {
  sourceId: String
}

input FindSemitagsOrderBy {
  createdAt: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input FindSoundcloudMADSourceInput {
  sourceId: String
  url: String
}

input FindSoundcloudRegistrationRequestInput {
  id: ID
  sourceId: String
}

input FindTagInput {
  id: ID
  serial: Int
}

input FindTagsInput {
  limit: Int! = 10

  """正確に一致"""
  name: String
  order: FindTagsInputOrder! = {updatedAt: DESC}
  parents: [ID!]
  skip: Int! = 0
}

input FindTagsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

type FindUncheckedNicovideoRegistrationRequestsByOffsetPayload {
  nodes: [NicovideoRegistrationRequest!]!
  totalCount: Int!
}

input FindUncheckedNicovideoRegistrationRequestsInput {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: FindUncheckedNicovideoRegistrationRequestsOrderBy! = {createdAt: DESC}
}

input FindUncheckedNicovideoRegistrationRequestsOrderBy {
  createdAt: SortOrder
}

input FindUncheckedSoundcloudRegistrationRequestsInput {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: FindUncheckedSoundcloudRegistrationRequestsOrderBy! = {createdAt: DESC}
}

input FindUncheckedSoundcloudRegistrationRequestsOrderBy {
  createdAt: SortOrder
}

input FindUncheckedYoutubeRegistrationRequestsInput {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: FindUncheckedYoutubeRegistrationRequestsOrderBy! = {createdAt: DESC}
}

input FindUncheckedYoutubeRegistrationRequestsOrderBy {
  createdAt: SortOrder
}

input FindUserInput {
  name: String
}

input FindVideoInput {
  id: ID
  serial: Int
}

input FindVideosOrderBy {
  createdAt: SortOrder
}

input FindYoutubeRegistrationRequestInput {
  id: ID
  sourceId: String
}

input FindYoutubeVideoSourceInput {
  sourceId: String
}

"""指定したTagParentRelationがそもそも非明示的だった場合のエラー"""
type ImplicitizeTagAlreadyImplicitError {
  relation: TagParent!
}

enum ImplicitizeTagOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type ImplicitizeTagOtherErrorsFallback {
  message: ImplicitizeTagOtherErrorMessage!
}

input ImplicitizeTagParentInput {
  """親子関係のID"""
  relationId: ID!
}

union ImplicitizeTagParentReturnUnion = ImplicitizeTagAlreadyImplicitError | ImplicitizeTagOtherErrorsFallback | ImplicitizeTagSucceededPayload | MutationInvalidTagParentIdError | MutationTagParentNotFoundError

type ImplicitizeTagSucceededPayload {
  relation: TagParent!
}

type LikeVideoAlreadyLikedError {
  registration: MylistRegistration!
}

input LikeVideoInput {
  videoId: ID!
}

union LikeVideoReturnUnion = LikeVideoAlreadyLikedError | LikeVideoSucceededPayload | MutationInvalidVideoIdError | MutationVideoNotFoundError

type LikeVideoSucceededPayload {
  registration: MylistRegistration!
}

input ListNicovideoBotRegistrationRequestsInput {
  limit: Int!
  skip: Int!
}

type MadCountGrowth {
  count: Int!
  date: DateTime!
}

"""音MADが登録されたことを表すタイムラインイベント"""
type MadRegisteredTimelineEvent implements TimelineEvent {
  createdAt: DateTime!
  event: VideoRegisterEvent!
  video: Video!
}

type Mutation {
  addMylistToMylistGroup(input: AddMylistToMylistGroupInput!): AddMylistToMylistGroupPayload!
  addSemitagToVideo(input: AddSemitagToVideoInput!): AddSemitagToVideoPayload!
  addTagToVideo(input: AddTagToVideoInput!): AddTagToVideoPayload!
  addVideoToMylist(input: AddVideoToMylistInput!): AddVideoToMylistReturnUnion!
  changeMylistShareRange(input: ChangeMylistShareRangeInput!): ChangeMylistShareReturnUnion!
  changeUserDisplayName(renameTo: String!): ChangeUserDisplayNameReturnUnion!
  createMylist(input: CreateMylistInput!): CreateMylistReturnUnion!
  createMylistGroup(input: CreateMylistGroupInput!): CreateMylistGroupPayload!

  """非明示的なタグの親子関係を明示的に昇格する"""
  explicitizeTagParent(input: ExplicitizeTagParentInput!): ExplicitizeTagParentReturnUnion!

  """明示的なタグの親子関係を非明示的に降格する"""
  implicitizeTagParent(input: ImplicitizeTagParentInput!): ImplicitizeTagParentReturnUnion!
  likeVideo(input: LikeVideoInput!): LikeVideoReturnUnion!
  registerBilibiliMAD(input: RegisterBilibiliMADInput!): RegisterBilibiliMADResult!
  registerCategoryTag(input: RegisterCategoryTagInput!): RegisterCategoryTagResultUnion!
  registerCategoryTagTyping(input: RegisterCategoryTagTypingInput!): RegisterCategoryTagTypingResultUnion!
  registerSoundcloudMAD(input: RegisterSoundcloudMADInput!): RegisterSoundcloudMADResult!
  registerTag(input: RegisterTagInput!): RegisterTagReturnUnion!
  registerTagParentRelation(input: RegisterTagParentRelationInput!): RegisterTagParentRelationResultUnion!
  registerVideoFromNicovideo(input: RegisterVideoFromNicovideoInput!): RegisterVideoFromNicovideoPayload!
  registerVideoFromYoutube(input: RegisterVideoFromYoutubeInput!): RegisterVideoFromYoutubePayload!
  rejectNicovideoRegistrationRequest(input: RejectNicovideoRegistrationRequestInput!): RejectNicovideoRegistrationRequestReturnUnion!
  rejectSemitag(semitagId: ID!): RejectSemitagReturnUnion!
  removeTagFromVideo(input: RemoveTagFromVideoInput!): RemoveTagFromVideoPayload!
  removeVideoFromMylist(input: RemoveVideoFromMylistInput!): RemoveVideoFromMylistPayload!
  requestNicovideoRegistration(input: RequestNicovideoRegistrationInput!): RequestNicovideoRegistrationReturnUnion!
  requestSoundcloudRegistration(input: RequestSoundcloudRegistrationInput!): RequestSoundcloudRegistrationReturnUnion!
  requestYoutubeRegistration(input: RequestYoutubeRegistrationInput!): RequestYoutubeRegistrationReturnUnion!
  resovleSemitag(semitagId: ID!, tagId: ID!): ResolveSemitagReturnUnion!
  undoLikeVideo(input: UndoLikeVideoInput!): UndoLikeVideoReturnUnion!

  """通知を見たことにする"""
  watchNotifications(input: WatchNotificationsInput!): WatchNotificationsReturnUnion!
}

type MutationInternalServerError {
  message: String
}

"""MylistのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidMylistIdError {
  """無効なID"""
  mylistId: String!
}

"""NicovideoRegistrationRequestのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidNicovideoRegistrationRequestIdError {
  """無効なID"""
  requestId: String!
}

"""SemitagのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidSemitagIdError {
  semitagId: String!
}

"""TagのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidTagIdError {
  """無効なID"""
  tagId: String!
}

"""TagParentのIDとして不正なIDを入力した場合のMutation用エラー"""
type MutationInvalidTagParentIdError {
  relationId: String!
}

"""VideoのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidVideoIdError {
  """無効なID"""
  videoId: String!
}

"""YoutubeRegistrationRequestのIDとして無効なIDを入力した場合のエラー"""
type MutationInvalidYoutubeRegistrationRequestIdError {
  """無効なID"""
  requestId: String!
}

"""Mylistが見つからない場合のエラー"""
type MutationMylistNotFoundError {
  mylistId: String!
}

"""既にチェック済みのNicovideoRegistrationRequestをチェックしようとした場合のエラー"""
type MutationNicovideoRegistrationRequestAlreadyCheckedError {
  requestId: String!
}

"""NicovideoRegistrationRequestが見つからない場合のエラー"""
type MutationNicovideoRegistrationRequestNotFoundError {
  requestId: String!
}

"""チェック済みのSemitagに操作を加えようとした場合のエラー"""
type MutationSemitagAlreadyCheckedError {
  semitag: Semitag!
}

"""Semitagが見つからない場合のエラー"""
type MutationSemitagNotFoundError {
  semitagId: String!
}

"""Tagが見つからない場合のエラー"""
type MutationTagNotFoundError {
  tagId: String!
}

"""TagParentが見つからない場合のMutation用エラー"""
type MutationTagParentNotFoundError {
  relationId: String!
}

"""Videoが見つからない場合のエラー"""
type MutationVideoNotFoundError {
  videoId: String!
}

"""Mylistの所有者が違う場合のエラー"""
type MutationWrongMylistHolderError {
  mylistId: String!
}

"""既にチェック済みのYoutubeRegistrationRequestをチェックしようとした場合のエラー"""
type MutationYoutubeRegistrationRequestAlreadyCheckedError {
  requestId: String!
}

"""YoutubeRegistrationRequestが見つからない場合のエラー"""
type MutationYoutubeRegistrationRequestNotFoundError {
  requestId: String!
}

type Mylist implements Node {
  createdAt: DateTime!
  holder: User!
  id: ID!
  includeTags(input: MylistIncludeTagsInput!): MylistIncludeTagsPayload!

  """マイリストの中にビデオが追加されているか．"""
  isIncludesVideo(id: ID!): Boolean!
  isLikeList: Boolean!
  range: MylistShareRange!
  recommendedVideos(input: MylistRecommendedVideosInput!): MylistRecommendedVideosPayload!
  registrations(after: String, before: String, first: Int, last: Int, orderBy: MylistRegistrationsOrderBy! = {createdAt: DESC}): MylistRegistrationConnection!

  """登録された音MADをoffsetベースで取得する"""
  registrationsByOffset(input: MylistRegistrationsByOffsetInput!): MylistRegistrationsByOffsetPayload!
  slug: String!
  title: String!
  updatedAt: DateTime!
}

type MylistConnection {
  edges: [MylistEdge!]!
  nodes: [Mylist!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MylistEdge {
  cursor: String!
  node: Mylist!
}

type MylistGroup implements Node {
  createdAt: DateTime!
  holder: User!
  id: ID!
  mylists(input: MylistGroupMylistsInput!): MylistGroupMylistInclusionConnection!
  title: String!
  updatedAt: DateTime!
  videos(input: MylistGroupVideosInput!): [MylistGroupVideoAggregation!]!
}

type MylistGroupMylistInclusion implements Node {
  createdAt: DateTime!
  group: MylistGroup!
  id: ID!
  mylist: Mylist!
  updatedAt: DateTime!
}

type MylistGroupMylistInclusionConnection {
  nodes: [MylistGroupMylistInclusion!]!
}

input MylistGroupMylistsInput {
  limit: Int! = 10
  order: MylistGroupMylistsInputOrder! = {createdAt: DESC}
  skip: Int! = 0
}

input MylistGroupMylistsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

type MylistGroupVideoAggregation {
  """動画を含んでいるマイリストの数"""
  count: Int!

  """動画を含んでいるマイリスト"""
  mylists(input: MylistGroupVideoAggregationMylistsInput!): [Mylist!]!
  video: Video!
}

input MylistGroupVideoAggregationMylistsInput {
  limit: Int! = 10
  order: MylistGroupVideoAggregationMylistsInputOrder! = {createdAt: DESC}
  skip: Int! = 0
}

input MylistGroupVideoAggregationMylistsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input MylistGroupVideosInput {
  limit: Int! = 10
  order: MylistGroupVideosInputOrder! = {count: DESC}
  skip: Int! = 0
}

input MylistGroupVideosInputOrder {
  count: SortOrder!
}

input MylistIncludeTagsInput {
  limit: Int! = 10
  order: MylistIncludeTagsInputOrder! = {count: DESC}
  skip: Int! = 0
}

input MylistIncludeTagsInputOrder {
  count: SortOrder!
}

type MylistIncludeTagsPayload {
  items: [MylistTagInclusion!]!
}

input MylistRecommendedVideosInput {
  limit: Int! = 10
}

type MylistRecommendedVideosPayload {
  items: [MylistVideoRecommendation!]!
}

type MylistRegistration implements Node {
  createdAt: DateTime!
  id: ID!
  mylist: Mylist!
  note: String
  updatedAt: DateTime!
  video: Video!
}

type MylistRegistrationConnection {
  edges: [MylistRegistrationEdge!]!
  nodes: [MylistRegistration!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MylistRegistrationEdge {
  cursor: String!
  node: MylistRegistration!
}

input MylistRegistrationsByOffsetInput {
  offset: Int!
  orderBy: MylistRegistrationsOrderBy! = {createdAt: DESC}
  take: Int!
}

type MylistRegistrationsByOffsetPayload {
  hasMore: Boolean!
  nodes: [MylistRegistration!]!
  totalCount: Int!
}

input MylistRegistrationsOrderBy {
  createdAt: SortOrder
}

enum MylistShareRange {
  KNOW_LINK
  PRIVATE
  PUBLIC
}

type MylistTagInclusion {
  count: Int!
  mylist: Mylist!
  tag: Tag!
}

type MylistVideoRecommendation {
  origin: Mylist!
  score: Float!
  to: Video!
}

"""ニコニコ動画の音MADがリクエストされたことを表すタイムラインイベント"""
type NicovideoMadRequestedTimelineEvent implements TimelineEvent {
  createdAt: DateTime!
  event: NicovideoRegistrationRequestRequestEvent!
  request: NicovideoRegistrationRequest!
}

type NicovideoOriginalSource {
  """ニコニコ動画の埋め込み用URL"""
  embedUrl: String!
  info: NicovideoOriginalSourceFreshInfo!

  """ニコニコ動画での動画ID"""
  sourceId: String!

  """ニコニコ動画での動画URL"""
  url: String!
}

"""ニコニコ動画のフレッシュな動画情報"""
type NicovideoOriginalSourceFreshInfo {
  """コメントの数"""
  countComments: Int!

  """いいね！の数"""
  countLikes: Int!

  """マイリストの数"""
  countMylists: Int!

  """再生数"""
  countViews: Int!

  """説明文"""
  description: String!

  """動画の長さ"""
  duration: Int!

  """「音MAD」など範囲が広すぎるので除外したタグ"""
  excludeTags: [String!]!

  """ニコニコ動画での投稿日時"""
  registeredAt: DateTime!

  """検索可能なタグ"""
  tags: [NicovideoOriginalSourceTag!]!

  """サムネイル画像のURL"""
  thumbnailUrl: String!

  """タイトル"""
  title: String!
}

type NicovideoOriginalSourceTag {
  name: String!
  searchTags(input: NicovideoOriginalSourceTagSearchTagsInput!): NicovideoOriginalSourceTagSearchTagsPayload!
}

input NicovideoOriginalSourceTagSearchTagsInput {
  limit: Int! = 3
  skip: Int! = 0
}

type NicovideoOriginalSourceTagSearchTagsPayload {
  items: [TagSearchItemByName!]!
}

type NicovideoRegistrationRequest implements Node & RegistrationRequest {
  checked: Boolean!
  checking: NicovideoRegistrationRequestChecking
  embedUrl: String!
  events(input: NicovideoRegistrationRequestEventsInput!): NicovideoRegistrationRequestEventConnection!
  id: ID!
  originalUrl: String!
  requestedBy: User!
  semitaggings: [NicovideoRegistrationRequestSemitagging!]!
  sourceId: String!
  taggings: [NicovideoRegistrationRequestTagging!]!
  thumbnailUrl: String!
  title: String!
}

"""ニコニコ動画の動画をリクエストを承認した時に発生するイベント"""
type NicovideoRegistrationRequestAcceptEvent implements Event & NicovideoRegistrationRequestEvent & Node {
  createdAt: DateTime!
  id: ID!
  request: NicovideoRegistrationRequest!
  series: String!
  user: User!
}

type NicovideoRegistrationRequestAccepting {
  acceptedBy: User!
  note: String
  request: NicovideoRegistrationRequest!
  video: Video!
}

type NicovideoRegistrationRequestAcceptingNotification implements Node & Notification {
  accepting: NicovideoRegistrationRequestAccepting!
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  watched: Boolean!
}

union NicovideoRegistrationRequestChecking = NicovideoRegistrationRequestAccepting | NicovideoRegistrationRequestRejecting

type NicovideoRegistrationRequestConnection {
  edges: [NicovideoRegistrationRequestEdge!]!
  nodes: [NicovideoRegistrationRequest!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NicovideoRegistrationRequestEdge {
  cursor: String!
  node: NicovideoRegistrationRequest!
}

"""ニコニコ動画の動画リクエスト関連のイベント"""
interface NicovideoRegistrationRequestEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  request: NicovideoRegistrationRequest!
  series: String!
  user: User!
}

type NicovideoRegistrationRequestEventConnection {
  edges: [NicovideoRegistrationRequestEventEdge!]!
  nodes: [NicovideoRegistrationRequestEvent!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NicovideoRegistrationRequestEventEdge {
  cursor: String!
  node: NicovideoRegistrationRequestEvent!
}

input NicovideoRegistrationRequestEventsInput {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: NicovideoRegistrationRequestEventsInputOrderBy! = {createdAt: DESC}
}

input NicovideoRegistrationRequestEventsInputOrderBy {
  createdAt: SortOrder
}

"""ニコニコ動画の動画をリクエストを拒否した時に発生するイベント"""
type NicovideoRegistrationRequestRejectEvent implements Event & NicovideoRegistrationRequestEvent & Node {
  createdAt: DateTime!
  id: ID!
  request: NicovideoRegistrationRequest!
  series: String!
  user: User!
}

type NicovideoRegistrationRequestRejecting {
  note: String
  rejectedBy: User!
  request: NicovideoRegistrationRequest!
}

type NicovideoRegistrationRequestRejectingNotification implements Node & Notification {
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  rejecting: NicovideoRegistrationRequestRejecting!
  watched: Boolean!
}

"""ニコニコ動画の動画をリクエスト時に発生するイベント"""
type NicovideoRegistrationRequestRequestEvent implements Event & NicovideoRegistrationRequestEvent & Node {
  createdAt: DateTime!
  id: ID!
  request: NicovideoRegistrationRequest!
  series: String!
  user: User!
}

type NicovideoRegistrationRequestSemitagging implements Node & RegistrationRequestSemitagging {
  id: ID!
  name: String!
  note: String
}

type NicovideoRegistrationRequestTagging implements Node & RegistrationRequestTagging {
  id: ID!
  note: String
  tag: Tag!
}

type NicovideoVideoSource implements Node & VideoSource {
  embedUrl: String!
  events(input: NicovideoVideoSourceEventsInput!): NicovideoVideoSourceEventConnection!
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type NicovideoVideoSourceCreateEvent implements Event & NicovideoVideoSourceEvent & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: NicovideoVideoSource!
  user: User!
}

interface NicovideoVideoSourceEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: NicovideoVideoSource!
  user: User!
}

type NicovideoVideoSourceEventConnection {
  nodes: [NicovideoVideoSourceEvent!]!
}

input NicovideoVideoSourceEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

interface Node {
  id: ID!
}

interface Notification implements Node {
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  watched: Boolean!
}

type NotificationConnection {
  edges: [NotificationEdge!]!
  nodes: [Notification!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NotificationEdge {
  cursor: String!
  node: Notification!
}

input NotificationsFilter {
  watched: Boolean
}

input NotificationsOrderBy {
  createdAt: SortOrder
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  """一定区間の音MADの登録個数の時系列データを計算する"""
  calcMadCountGrowth(input: CalcMadCountGrowthInput!): [MadCountGrowth]!

  """全ての音MADの個数を数える"""
  countAllMads: Int!

  """全てのタグの個数を数える"""
  countAllTags: Int!

  """Bilibiliから動画情報を取得する"""
  fetchBilibili(input: FetchBilibiliInput!): FetchBilibiliPayload!

  """ニコニコ動画から動画情報を取得する"""
  fetchNicovideo(input: FetchNicovideoInput!): FetchNicovideoPayload!

  """SoundCloudから動画情報を取得する"""
  fetchSoundcloud(input: FetchSoundcloudInput!): FetchSoundcloudPayload!

  """Youtubeから動画情報を取得する"""
  fetchYoutube(input: FetchYoutubeInput!): FetchYoutubePayload!
  findBilibiliMADSource(input: FindBilibiliMADSourceInput!): BilibiliMADSource
  findMadBySerial(serial: Int!): Video
  findMadsByOffset(input: FindMadsByOffsetInput!): FindMadsByOffsetPayload!
  findMylist(input: FindMylistInput!): Mylist
  findNicovideoRegistrationRequest(input: FindNicovideoRegistrationRequestInput): NicovideoRegistrationRequest
  findNicovideoRegistrationRequests(after: String, before: String, checked: Boolean, first: Int, last: Int, orderBy: FindNicovideoRegistrationRequestsOrderBy! = {createdAt: DESC}): NicovideoRegistrationRequestConnection!
  findNicovideoVideoSource(input: FindNicovideoVideoSourceInput!): NicovideoVideoSource
  findSemitags(after: String, before: String, checked: Boolean, first: Int, last: Int, orderBy: FindSemitagsOrderBy! = {name: ASC}): SemitagConnection!
  findSoundcloudMADSource(input: FindSoundcloudMADSourceInput!): SoundcloudMADSource
  findSoundcloudRegistrationRequest(input: FindSoundcloudRegistrationRequestInput): SoundcloudRegistrationRequest
  findSoundcloudRegistrationRequestByUrl(url: String!): SoundcloudRegistrationRequest
  findTag(input: FindTagInput!): Tag @deprecated(reason: "Use `Query.findTagBySerial` instead.")
  findTagBySerial(serial: Int!): Tag
  findTags(input: FindTagsInput!): TagConnection!
  findUncheckedNicovideoRegistrationRequests(input: FindUncheckedNicovideoRegistrationRequestsInput!): NicovideoRegistrationRequestConnection!
  findUncheckedNicovideoRegistrationRequestsByOffset(input: findUncheckedNicovideoRegistrationRequestsByOffsetInput!): FindUncheckedNicovideoRegistrationRequestsByOffsetPayload!
  findUncheckedSoundcloudRegistrationRequests(input: FindUncheckedSoundcloudRegistrationRequestsInput!): SoundcloudRegistrationRequestConnection!
  findUncheckedYoutubeRegistrationRequests(input: FindUncheckedYoutubeRegistrationRequestsInput!): YoutubeRegistrationRequestConnection!
  findUser(input: FindUserInput!): User
  findVideo(input: FindVideoInput!): Video @deprecated(reason: "Use `Query.findMadBySerial` instead")
  findVideos(after: String, before: String, first: Int, last: Int, orderBy: FindVideosOrderBy! = {createdAt: DESC}): VideoConnection!
  findYoutubeRegistrationRequest(input: FindYoutubeRegistrationRequestInput): YoutubeRegistrationRequest
  findYoutubeVideoSource(input: FindYoutubeVideoSourceInput!): YoutubeVideoSource
  getAllCategoryTag: [Tag!]!

  """全てのTypeCategoryTagを取得する"""
  getAllTypeCategoryTag: [TypeCategoryTag!]!
  getBilibiliMADSource(id: ID!): BilibiliMADSource!
  getMylist(id: ID!): Mylist!
  getMylistGroup(id: ID!): MylistGroup!
  getNicovideoRegistrationRequest(id: ID!): NicovideoRegistrationRequest!
  getNicovideoVideoSource(id: ID!): NicovideoVideoSource!
  getNotification(id: ID!): Notification!
  getSemitag(id: ID!): Semitag!
  getSoundcloudMADSource(id: ID!): SoundcloudMADSource!
  getSoundcloudRegistrationRequest(id: ID!): SoundcloudRegistrationRequest!
  getTag(id: ID!): Tag!
  getUser(id: ID!): User!
  getVideo(id: ID!): Video!
  getYoutubeRegistrationRequest(id: ID!): YoutubeRegistrationRequest!
  getYoutubeVideoSource(id: ID!): YoutubeVideoSource!

  """自動的に検知したニコニコ動画の音MADを列挙する"""
  listNicovideoBotRegistrationRequests(input: ListNicovideoBotRegistrationRequestsInput!): [NicovideoOriginalSource!]!
  notifications(after: String, before: String, filter: NotificationsFilter! = {}, first: Int, last: Int, orderBy: NotificationsOrderBy! = {createdAt: DESC}): NotificationConnection!
  searchTags(input: SearchTagInput!): SearchTagsPayload!
  searchVideos(input: SearchVideoInput!): SearchVideosPayload!

  """ユーザーのタイムラインを取得する"""
  showTimeline(input: ShowTimelineInput!): [TimelineEvent!]!
  whoami: User!
  viewer: User
}

input RegisterBilibiliMADInput {
  primaryThumbnailUrl: String!
  primaryTitle: String!
  semitagNames: [String!]! = []
  sourceIds: [String!]!
  tagIds: [ID!]!
}

union RegisterBilibiliMADResult = MutationInternalServerError | MutationTagNotFoundError | RegisterBilibiliMADSucceededPayload

type RegisterBilibiliMADSucceededPayload {
  video: Video!
}

input RegisterCategoryTagInput {
  primaryName: String!
}

union RegisterCategoryTagResultUnion = RegisterCategoryTagSucceededPayload

type RegisterCategoryTagSucceededPayload {
  tag: Tag!
}

"""指定されたタイプのカテゴリータグが既に存在する場合のエラー"""
type RegisterCategoryTagTypingAlreadyTypeExistsError {
  already: Tag!
}

"""指定されたカテゴリータグに既にタイプがある場合のエラー"""
type RegisterCategoryTagTypingAlreadyTypedError {
  tag: Tag!
}

input RegisterCategoryTagTypingInput {
  tagId: ID!
  type: TypeCategoryTagType!
}

"""指定されたタグはカテゴリータグでは無い場合のエラー"""
type RegisterCategoryTagTypingNotCategoryTagError {
  tag: Tag!
}

union RegisterCategoryTagTypingResultUnion = MutationInvalidTagIdError | MutationTagNotFoundError | RegisterCategoryTagTypingAlreadyTypeExistsError | RegisterCategoryTagTypingAlreadyTypedError | RegisterCategoryTagTypingNotCategoryTagError | RegisterCategoryTagTypingSucceededPayload

type RegisterCategoryTagTypingSucceededPayload {
  tag: Tag!
}

input RegisterSoundcloudMADInput {
  primaryThumbnailUrl: String
  primaryTitle: String!
  semitagNames: [String!]! = []
  sourceIds: [String!]!
  tagIds: [ID!]!
}

union RegisterSoundcloudMADResult = MutationInternalServerError | MutationTagNotFoundError | RegisterSoundcloudMADSucceededPayload

type RegisterSoundcloudMADSucceededPayload {
  mad: Video!
}

"""非明示的な親タグのIDが重複している"""
type RegisterTagImplicitParentIdsDuplicatedError {
  tagId: String!
}

input RegisterTagInput {
  explicitParent: ID
  extraNames: [String!]! = []
  implicitParents: [ID!]! = []
  primaryName: String!
  resolveSemitags: [ID!]! = []
}

type RegisterTagOtherErrorsFallback {
  message: RegisterTagOtherErrorsFallbackMessage!
}

enum RegisterTagOtherErrorsFallbackMessage {
  UNKNOWN
}

"""子タグに既に明示的な親子関係が存在する場合のエラー"""
type RegisterTagParentRelationChildTagAlreadyHadExplicitParentError {
  relation: TagParent!
}

input RegisterTagParentRelationInput {
  childId: ID!
  explicit: Boolean!
  parentId: ID!
}

enum RegisterTagParentRelationOtherErrorMessage {
  INTERNAL_SERVER_ERROR
}

"""その他のエラー"""
type RegisterTagParentRelationOtherErrorsFallback {
  message: RegisterTagParentRelationOtherErrorMessage!
}

"""既に登録されていた場合のエラー"""
type RegisterTagParentRelationRelationAlreadyRegisteredError {
  relation: TagParent!
}

union RegisterTagParentRelationResultUnion = MutationInvalidTagIdError | MutationTagNotFoundError | RegisterTagParentRelationChildTagAlreadyHadExplicitParentError | RegisterTagParentRelationOtherErrorsFallback | RegisterTagParentRelationRelationAlreadyRegisteredError | RegisterTagParentRelationSucceededPayload

type RegisterTagParentRelationSucceededPayload {
  relation: TagParent!
}

"""解決されるSemitagが既にチェック済みである"""
type RegisterTagResolveSemitagAlreadyCheckedError {
  semitagId: String!
}

"""解決されるSemitagのIDが重複している"""
type RegisterTagResolveSemitagIdsDuplicatedError {
  semitagId: String!
}

union RegisterTagReturnUnion = MutationInvalidSemitagIdError | MutationInvalidTagIdError | MutationSemitagNotFoundError | MutationTagNotFoundError | RegisterTagImplicitParentIdsDuplicatedError | RegisterTagOtherErrorsFallback | RegisterTagResolveSemitagAlreadyCheckedError | RegisterTagResolveSemitagIdsDuplicatedError | RegisterTagSucceededPayload | RegisterTagTagIdCollidedBetweenExplicitAndImplicitError

type RegisterTagSucceededPayload {
  tag: Tag!
}

"""明示的な親タグのIDと非明示的な親タグのIDが重複している"""
type RegisterTagTagIdCollidedBetweenExplicitAndImplicitError {
  tagId: String!
}

input RegisterVideoFromNicovideoInput {
  extraTitles: [String!]! = []
  primaryThumbnailUrl: String!
  primaryTitle: String!
  requestId: ID
  semitagNames: [String!]! = []
  sourceIds: [String!]!
  tagIds: [ID!]!
}

"""ニコニコ動画のソースIDとして不正な場合のエラー"""
type RegisterVideoFromNicovideoInvalidNicovideoSourceIdError {
  sourceID: String!
}

union RegisterVideoFromNicovideoPayload = MutationInvalidNicovideoRegistrationRequestIdError | MutationInvalidTagIdError | MutationNicovideoRegistrationRequestAlreadyCheckedError | MutationNicovideoRegistrationRequestNotFoundError | MutationTagNotFoundError | RegisterVideoFromNicovideoInvalidNicovideoSourceIdError | RegisterVideoFromNicovideoSemitagNamesDuplicatedError | RegisterVideoFromNicovideoSemitagTooLongError | RegisterVideoFromNicovideoSucceededPayload | RegisterVideoFromNicovideoTagIdsDuplicatedError

"""仮タグの名前が重複している"""
type RegisterVideoFromNicovideoSemitagNamesDuplicatedError {
  name: String!
}

"""仮タグの名前が長過ぎる"""
type RegisterVideoFromNicovideoSemitagTooLongError {
  name: String!
}

"""成功した場合"""
type RegisterVideoFromNicovideoSucceededPayload {
  video: Video!
}

"""タグのIDが重複している"""
type RegisterVideoFromNicovideoTagIdsDuplicatedError {
  tagId: String!
}

enum RegisterVideoFromYoutubeFailedMessage {
  INTERNAL_SERVER_ERROR
}

input RegisterVideoFromYoutubeInput {
  extraTitles: [String!]! = []
  primaryThumbnailUrl: String!
  primaryTitle: String!

  """解決するYoutubeRegistrationRequestのID"""
  requestId: ID
  semitagNames: [String!]! = []
  sourceIds: [String!]!
  tagIds: [ID!]!
}

"""Youtubeの動画IDとして不正な場合のエラー"""
type RegisterVideoFromYoutubeInvalidYoutubeSourceIdError {
  sourceID: String!
}

"""その他のエラー"""
type RegisterVideoFromYoutubeOtherErrorsFallback {
  message: RegisterVideoFromYoutubeFailedMessage!
}

union RegisterVideoFromYoutubePayload = MutationInvalidTagIdError | MutationInvalidYoutubeRegistrationRequestIdError | MutationTagNotFoundError | MutationYoutubeRegistrationRequestAlreadyCheckedError | MutationYoutubeRegistrationRequestNotFoundError | RegisterVideoFromYoutubeInvalidYoutubeSourceIdError | RegisterVideoFromYoutubeOtherErrorsFallback | RegisterVideoFromYoutubeSemitagNamesDuplicatedError | RegisterVideoFromYoutubeSucceededPayload | RegisterVideoFromYoutubeTagIdsDuplicatedError

"""仮タグの名前が重複している"""
type RegisterVideoFromYoutubeSemitagNamesDuplicatedError {
  name: String!
}

"""成功した場合"""
type RegisterVideoFromYoutubeSucceededPayload {
  video: Video!
}

"""タグのIDが重複している"""
type RegisterVideoFromYoutubeTagIdsDuplicatedError {
  tagId: String!
}

interface RegistrationRequest implements Node {
  checked: Boolean!
  id: ID!
  originalUrl: String!
  requestedBy: User!
  semitaggings: [RegistrationRequestSemitagging!]!
  sourceId: String!
  taggings: [RegistrationRequestTagging!]!
  thumbnailUrl: String!
  title: String!
}

interface RegistrationRequestSemitagging implements Node {
  id: ID!
  name: String!
  note: String
}

interface RegistrationRequestTagging implements Node {
  id: ID!
  note: String
  tag: Tag!
}

input RejectNicovideoRegistrationRequestInput {
  note: String!
  requestId: ID!
}

"""リクエストが既に処理されている場合のエラー"""
type RejectNicovideoRegistrationRequestRequestAlreadyCheckedError {
  request: NicovideoRegistrationRequest!
}

union RejectNicovideoRegistrationRequestReturnUnion = MutationInvalidNicovideoRegistrationRequestIdError | MutationNicovideoRegistrationRequestNotFoundError | RejectNicovideoRegistrationRequestRequestAlreadyCheckedError | RejectNicovideoRegistrationRequestSucceededPayload

type RejectNicovideoRegistrationRequestSucceededPayload {
  rejecting: NicovideoRegistrationRequestRejecting!
}

"""その他のエラー"""
type RejectSemitagOtherErrorsFallback {
  message: RejectSemitagOtherErrorsFallbackMessage!
}

enum RejectSemitagOtherErrorsFallbackMessage {
  INTERNAL_SERVER_ERROR
}

union RejectSemitagReturnUnion = MutationInvalidSemitagIdError | MutationInvalidTagIdError | MutationSemitagAlreadyCheckedError | MutationSemitagNotFoundError | MutationTagNotFoundError | RejectSemitagOtherErrorsFallback | RejectSemitagSucceededPayload

type RejectSemitagSucceededPayload {
  rejecting: SemitagRejecting!
}

enum RemoveTagFromVideoFailedMessage {
  FORBIDDEN
  INVALID_TAG_ID
  INVALID_VIDEO_ID
  NO_TAGGING
  TAGGING_ALREADY_REMOVED
  TAG_NOT_FOUND

  """原因不明のエラー"""
  UNKNOWN
  VIDEO_NOT_FOUND
}

type RemoveTagFromVideoFailedPayload {
  message: RemoveTagFromVideoFailedMessage!
}

input RemoveTagFromVideoInput {
  tagId: ID!
  videoId: ID!
}

union RemoveTagFromVideoPayload = RemoveTagFromVideoFailedPayload | RemoveTagFromVideoSucceededPayload

type RemoveTagFromVideoSucceededPayload {
  tag: Tag!
  video: Video!
}

enum RemoveVideoFromMylistFailedMessage {
  ALREADY_UNREGISTERED
  FORBIDDEN
  INVALID_MYLIST_ID
  INVALID_VIDEO_ID
  MYLIST_NOT_FOUND
  NOT_REGISTERED
  UNKNOWN
  VIDEO_NOT_FOUND
  WRONG_MYLIST_HOLDER
}

type RemoveVideoFromMylistFailedPayload {
  message: RemoveVideoFromMylistFailedMessage!
}

input RemoveVideoFromMylistInput {
  mylistId: ID!
  videoId: ID!
}

union RemoveVideoFromMylistPayload = RemoveVideoFromMylistFailedPayload | RemoveVideoFromMylistSucceededPayload

type RemoveVideoFromMylistSucceededPayload {
  mylist: Mylist!
  video: Video!
}

input RequestNicovideoRegistrationInput {
  semitaggings: [RequestNicovideoRegistrationInputSemitagging!]!
  sourceId: String!
  taggings: [RequestNicovideoRegistrationInputTagging!]!
  thumbnailUrl: String!
  title: String!
}

input RequestNicovideoRegistrationInputSemitagging {
  name: String!
  note: String
}

input RequestNicovideoRegistrationInputTagging {
  note: String
  tagId: ID!
}

union RequestNicovideoRegistrationReturnUnion = MutationInvalidTagIdError | MutationTagNotFoundError | RequestNicovideoRegistrationSucceededPayload | RequestNicovideoRegistrationVideoAlreadyRegisteredError

type RequestNicovideoRegistrationSucceededPayload {
  request: NicovideoRegistrationRequest!
}

"""動画が既に登録されている場合のエラー"""
type RequestNicovideoRegistrationVideoAlreadyRegisteredError {
  source: NicovideoVideoSource!
}

input RequestSoundcloudRegistrationInput {
  semitaggings: [RequestSoundcloudRegistrationInputSemitagging!]!
  sourceId: String!
  taggings: [RequestSoundcloudRegistrationInputTagging!]!

  """プラットフォーム側のサムネイル画像のURL（無い場合もある）"""
  thumbnailUrl: String
  title: String!
}

input RequestSoundcloudRegistrationInputSemitagging {
  name: String!
  note: String
}

input RequestSoundcloudRegistrationInputTagging {
  note: String
  tagId: ID!
}

union RequestSoundcloudRegistrationReturnUnion = MutationInvalidTagIdError | MutationTagNotFoundError | RequestSoundcloudRegistrationSucceededPayload | RequestSoundcloudRegistrationVideoAlreadyRegisteredError

type RequestSoundcloudRegistrationSucceededPayload {
  request: SoundcloudRegistrationRequest!
}

"""動画が既に登録されている場合のエラー"""
type RequestSoundcloudRegistrationVideoAlreadyRegisteredError {
  source: SoundcloudMADSource!
}

input RequestYoutubeRegistrationInput {
  semitaggings: [RequestYoutubeRegistrationInputSemitagging!]!
  sourceId: String!
  taggings: [RequestYoutubeRegistrationInputTagging!]!
  thumbnailUrl: String!
  title: String!
}

input RequestYoutubeRegistrationInputSemitagging {
  name: String!
  note: String
}

input RequestYoutubeRegistrationInputTagging {
  note: String
  tagId: ID!
}

union RequestYoutubeRegistrationReturnUnion = MutationInvalidTagIdError | MutationTagNotFoundError | RequestYoutubeRegistrationSucceededPayload | RequestYoutubeRegistrationVideoAlreadyRegisteredError

type RequestYoutubeRegistrationSucceededPayload {
  request: YoutubeRegistrationRequest!
}

"""動画が既に登録されている場合のエラー"""
type RequestYoutubeRegistrationVideoAlreadyRegisteredError {
  source: YoutubeVideoSource!
}

"""その他のエラー"""
type ResolveSemitagOtherErrorsFallback {
  message: ResolveSemitagOtherErrorsFallbackMessage!
}

enum ResolveSemitagOtherErrorsFallbackMessage {
  INTERNAL_SERVER_ERROR
}

union ResolveSemitagReturnUnion = MutationInvalidSemitagIdError | MutationInvalidTagIdError | MutationSemitagAlreadyCheckedError | MutationSemitagNotFoundError | MutationTagNotFoundError | ResolveSemitagOtherErrorsFallback | ResolveSemitagSucceededPayload | ResolveSemitagVideoAlreadyTaggedPayload

type ResolveSemitagSucceededPayload {
  resolving: SemitagResolving!
}

"""すでに動画に同じタグ付けが行われている場合のエラー"""
type ResolveSemitagVideoAlreadyTaggedPayload {
  tagging: VideoTag!
}

input SearchTagInput {
  limit: Int! = 10
  query: String!
  skip: Int! = 0
}

type SearchTagsPayload {
  items: [TagSearchItemByName!]!
}

input SearchVideoInput {
  limit: Int! = 10
  query: String!
  skip: Int! = 0
}

type SearchVideosPayload {
  items: [VideoSearchItemByTitle!]!
}

type Semitag implements Node {
  check: SemitagChecking
  checked: Boolean!
  events(input: SemitagEventsInput!): SemitagEventConnection!
  id: ID!
  name: String!
  resolved: Boolean! @deprecated
  resolvedTag: Tag @deprecated
  suggestTags(limit: Int! = 3, skip: Int! = 0): SemitagSuggestTagsReturn!
  video: Video!
}

type SemitagAttachEvent implements Event & Node & SemitagEvent {
  createdAt: DateTime!
  id: ID!
  semitag: Semitag!
  series: String!
  user: User!
}

union SemitagChecking = SemitagRejecting | SemitagResolving

type SemitagConnection {
  edges: [SemitagEdge!]!
  nodes: [Semitag!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SemitagEdge {
  cursor: String!
  node: Semitag!
}

interface SemitagEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
}

type SemitagEventConnection {
  nodes: [SemitagEvent!]!
}

input SemitagEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type SemitagRejectEvent implements Event & Node & SemitagEvent {
  createdAt: DateTime!
  id: ID!
  rejecting: SemitagRejecting!
  series: String!
  user: User!
}

type SemitagRejecting {
  note: String
  semitag: Semitag!
}

type SemitagResolveEvent implements Event & Node & SemitagEvent {
  createdAt: DateTime!
  id: ID!
  resolving: SemitagResolving!
  series: String!
  user: User!
}

type SemitagResolving {
  note: String
  resolveTo: VideoTag!
  semitag: Semitag!
}

type SemitagSuggestTagsItem {
  canResolveTo: Boolean!
  name: TagName!
  tag: Tag!
}

type SemitagSuggestTagsReturn {
  items: [SemitagSuggestTagsItem!]!
}

input ShowTimelineInput {
  skip: Int!
  take: Int!
}

enum SortOrder {
  ASC
  DESC
}

type SoundcloudMADSource implements Node & VideoSource {
  embedUrl: String!
  events(after: String, before: String, first: Int, last: Int, orderBy: SoundcloudMADSourceEventsOrderBy!): SoundcloudMADSourceEventConnection!
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type SoundcloudMADSourceCreateEvent implements Event & Node & SoundcloudMADSourceEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: SoundcloudMADSource!
  user: User!
}

interface SoundcloudMADSourceEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: SoundcloudMADSource!
  user: User!
}

type SoundcloudMADSourceEventConnection {
  edges: [SoundcloudMADSourceEventEdge!]!
  nodes: [SoundcloudMADSourceEvent!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SoundcloudMADSourceEventEdge {
  cursor: String!
  node: SoundcloudMADSourceEvent!
}

input SoundcloudMADSourceEventsOrderBy {
  createdAt: SortOrder
}

"""SoundCloudの音MADがリクエストされたことを表すタイムラインイベント"""
type SoundcloudMadRequestedTimelineEvent implements TimelineEvent {
  createdAt: DateTime!
  event: SoundcloudRegistrationRequestRequestEvent!
  request: SoundcloudRegistrationRequest!
}

type SoundcloudOriginalSource {
  """SoundCloud側のサムネイル画像（場合によってはない可能性がある）"""
  originalThumbnailUrl: String
  sourceId: String!

  """プロキシしたサムネイル画像"""
  thumbnailUrl(scale: FetchExternalSourceThumbnailScale! = LARGE): String
  title: String!
  url: String!
}

type SoundcloudRegistrationRequest implements Node & RegistrationRequest {
  checked: Boolean!
  checking: SoundcloudRegistrationRequestChecking
  embedUrl: String!
  events(input: SoundcloudRegistrationRequestEventsInput!): SoundcloudRegistrationRequestEventConnection!
  id: ID!

  """
  Soundcloud側のサムネイル画像のURL

  **無い場合もある場合に注意.**
  """
  originalThumbnailUrl: String
  originalUrl: String!
  requestedBy: User!
  semitaggings: [SoundcloudRegistrationRequestSemitagging!]!
  sourceId: String!
  taggings: [SoundcloudRegistrationRequestTagging!]!

  """
  OtoMADB側でプロキシしているサムネイル画像のURL

  **無い場合は適当にダミー画像を返す．**
  """
  thumbnailUrl: String!
  title: String!
}

"""Soundcloudの動画をリクエストを承認した時に発生するイベント"""
type SoundcloudRegistrationRequestAcceptEvent implements Event & Node & SoundcloudRegistrationRequestEvent {
  createdAt: DateTime!
  id: ID!
  request: SoundcloudRegistrationRequest!
  series: String!
  user: User!
}

type SoundcloudRegistrationRequestAccepting {
  acceptedBy: User!
  note: String
  request: SoundcloudRegistrationRequest!
  video: Video!
}

type SoundcloudRegistrationRequestAcceptingNotification implements Node & Notification {
  accepting: SoundcloudRegistrationRequestAccepting!
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  watched: Boolean!
}

union SoundcloudRegistrationRequestChecking = SoundcloudRegistrationRequestAccepting | SoundcloudRegistrationRequestRejecting

type SoundcloudRegistrationRequestConnection {
  edges: [SoundcloudRegistrationRequestEdge!]!
  nodes: [SoundcloudRegistrationRequest!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SoundcloudRegistrationRequestEdge {
  cursor: String!
  node: SoundcloudRegistrationRequest!
}

"""Soundcloudの動画リクエスト関連のイベント"""
interface SoundcloudRegistrationRequestEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  request: SoundcloudRegistrationRequest!
  series: String!
  user: User!
}

type SoundcloudRegistrationRequestEventConnection {
  edges: [SoundcloudRegistrationRequestEventEdge!]!
  nodes: [SoundcloudRegistrationRequestEvent!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SoundcloudRegistrationRequestEventEdge {
  cursor: String!
  node: SoundcloudRegistrationRequestEvent!
}

input SoundcloudRegistrationRequestEventsInput {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: SoundcloudRegistrationRequestEventsInputOrderBy! = {createdAt: DESC}
}

input SoundcloudRegistrationRequestEventsInputOrderBy {
  createdAt: SortOrder
}

"""Soundcloudの動画をリクエストを拒否した時に発生するイベント"""
type SoundcloudRegistrationRequestRejectEvent implements Event & Node & SoundcloudRegistrationRequestEvent {
  createdAt: DateTime!
  id: ID!
  request: SoundcloudRegistrationRequest!
  series: String!
  user: User!
}

type SoundcloudRegistrationRequestRejecting {
  note: String
  rejectedBy: User!
  request: SoundcloudRegistrationRequest!
}

type SoundcloudRegistrationRequestRejectingNotification implements Node & Notification {
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  rejecting: SoundcloudRegistrationRequestRejecting!
  watched: Boolean!
}

"""Soundcloudの動画をリクエスト時に発生するイベント"""
type SoundcloudRegistrationRequestRequestEvent implements Event & Node & SoundcloudRegistrationRequestEvent {
  createdAt: DateTime!
  id: ID!
  request: SoundcloudRegistrationRequest!
  series: String!
  user: User!
}

type SoundcloudRegistrationRequestSemitagging implements Node & RegistrationRequestSemitagging {
  id: ID!
  name: String!
  note: String
}

type SoundcloudRegistrationRequestTagging implements Node & RegistrationRequestTagging {
  id: ID!
  note: String
  tag: Tag!
}

type Tag implements Node {
  """動画に対してタグを付けることができるか"""
  canTagTo(
    """動画のID"""
    videoId: ID!
  ): Boolean!
  children(after: String, before: String, first: Int, last: Int, orderBy: TagChildrenOrderBy! = {createdAt: DESC}): TagParentConnection!
  events(input: TagEventsInput!): TagEventsConnection!
  explicitParent: Tag
  id: ID!
  isCategoryTag: Boolean! @deprecated
  meaningless: Boolean! @deprecated
  name: String!
  names(primary: Boolean): [TagName!]!
  parents(after: String, before: String, categoryTag: Boolean, first: Int, last: Int, orderBy: TagParentsOrderBy! = {createdAt: DESC}): TagParentConnection!
  serial: Int!
  taggedVideos(after: String, before: String, first: Int, last: Int, orderBy: TagTaggedVideosOrderBy! = {createdAt: DESC}): VideoTagConnection!

  """offsetベースでタグ付けされた動画を取得する"""
  taggedVideosByOffset(input: TaggedVideosByOffsetInput!): TagTaggedVideosByOffsetPayload!
  totalTaggedVideos: Int!
  type: TagType!
}

input TagChildrenOrderBy {
  createdAt: SortOrder
}

type TagConnection {
  nodes: [Tag!]!
}

interface TagEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  tag: Tag!
  user: User!
}

type TagEventsConnection {
  nodes: [TagEvent!]!
}

input TagEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type TagName {
  events(input: TagNameEventsInput!): TagNameEventConnection!
  id: ID!
  name: String!
  primary: Boolean!
}

type TagNameCreateEvent implements Event & Node & TagNameEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagName: TagName!
  user: User!
}

interface TagNameEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagName: TagName!
  user: User!
}

type TagNameEventConnection {
  nodes: [TagNameEvent!]!
}

input TagNameEventsInput {
  limit: Int
  skip: Int! = 0
}

type TagNameSetPrimaryEvent implements Event & Node & TagNameEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagName: TagName!
  user: User!
}

type TagNameUnsetPrimaryEvent implements Event & Node & TagNameEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagName: TagName!
  user: User!
}

type TagParent {
  child: Tag!
  events(input: TagParentEventsInput!): TagParentEventConnection!
  explicit: Boolean!
  id: ID!
  parent: Tag!
}

type TagParentConnection {
  edges: [TagParentEdge!]!
  nodes: [TagParent!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TagParentCreateEvent implements Event & Node & TagParentEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagParent: TagParent!
  user: User!
}

type TagParentEdge {
  cursor: String!
  node: TagParent!
}

interface TagParentEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagParent: TagParent!
  user: User!
}

type TagParentEventConnection {
  nodes: [TagParentEvent!]!
}

input TagParentEventsInput {
  limit: Int
  skip: Int! = 0
}

type TagParentSetPrimaryEvent implements Event & Node & TagParentEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagParent: TagParent!
  user: User!
}

type TagParentUnsetPrimaryEvent implements Event & Node & TagParentEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tagParent: TagParent!
  user: User!
}

input TagParentsOrderBy {
  createdAt: SortOrder
}

"""Tagを追加した際に発生．（初回のみ）"""
type TagRegisterEvent implements Event & Node & TagEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  tag: Tag!
  user: User!
}

type TagSearchItemByName {
  name: TagName!
  tag: Tag!
}

type TagTaggedVideosByOffsetPayload {
  hasMore: Boolean!
  nodes: [VideoTag!]!
  totalCount: Int!
}

input TagTaggedVideosOrderBy {
  createdAt: SortOrder
}

enum TagType {
  """カテゴリー"""
  CATEGORY

  """キャラクター"""
  CHARACTER

  """動画の内容に依らない情報，分類など"""
  CLASS

  """作品名"""
  COPYRIGHT

  """合作などのイベント"""
  EVENT

  """曲"""
  MUSIC

  """特徴的なセリフなど"""
  PHRASE

  """シリーズ"""
  SERIES

  """動画そのものに対しての性質，作風など"""
  STYLE

  """2つ以上のタイプが算出された場合"""
  SUBTLE

  """戦法"""
  TACTICS

  """タイプを算出できなかった場合"""
  UNKNOWN
}

input TaggedVideosByOffsetInput {
  offset: Int!
  orderBy: TagTaggedVideosOrderBy! = {createdAt: DESC}
  take: Int!
}

interface TimelineEvent {
  createdAt: DateTime!
  event: Event!
}

"""タグにタイプを与えることが出来るカテゴリータグ"""
type TypeCategoryTag {
  tag: Tag!
  type: TypeCategoryTagType!
}

enum TypeCategoryTagType {
  """キャラクター"""
  CHARACTER

  """動画の内容に依らない情報，分類など"""
  CLASS

  """作品名"""
  COPYRIGHT

  """合作などのイベント"""
  EVENT

  """曲"""
  MUSIC

  """特徴的なセリフなど"""
  PHRASE

  """シリーズ"""
  SERIES

  """動画そのものに対しての性質，作風など"""
  STYLE

  """戦法"""
  TACTICS
}

input UndoLikeVideoInput {
  videoId: ID!
}

type UndoLikeVideoNotLikedError {
  likes: Mylist!
  video: Video!
}

union UndoLikeVideoReturnUnion = MutationInvalidVideoIdError | MutationVideoNotFoundError | UndoLikeVideoNotLikedError | UndoLikeVideoSucceededPayload

type UndoLikeVideoSucceededPayload {
  registration: MylistRegistration!
}

type User implements Node {
  displayName: String!
  hasRole(role: UserRole!): Boolean
  icon: String!
  id: ID!
  isAdministrator: Boolean! @deprecated(reason: "Use hasRole instead.")
  isEditor: Boolean! @deprecated(reason: "Use hasRole instead.")
  likes: Mylist
  mylist(id: ID!): Mylist
  mylists(after: String, before: String, first: Int, last: Int, orderBy: UserMylistsOrderBy! = {createdAt: DESC}, range: [MylistShareRange!]! = [PUBLIC]): MylistConnection!
  name: String!
  nicovideoRegistrationRequests(after: String, before: String, first: Int, last: Int, orderBy: UserNicovideoRegistrationRequestsOrderBy! = {createdAt: DESC}): NicovideoRegistrationRequestConnection!

  """現在このユーザに届いている通知．"""
  notifications(input: UserNotificationsInput!): NotificationConnection!
}

input UserMylistsOrderBy {
  createdAt: SortOrder
}

input UserNicovideoRegistrationRequestsOrderBy {
  createdAt: SortOrder
}

input UserNotificationsFilter {
  watched: Boolean
}

input UserNotificationsInput {
  after: String
  before: String
  filter: UserNotificationsFilter! = {}
  first: Int
  last: Int
  orderBy: UserNotificationsOrderBy! = {createdAt: DESC}
}

input UserNotificationsOrderBy {
  createdAt: SortOrder
}

enum UserRole {
  ADMIN
  EDITOR
}

type Video implements Node {
  bilibiliSources: [BilibiliMADSource!]!
  events(input: VideoEventsInput!): VideoEventsConnection!
  hasTag(id: ID!): Boolean!
  id: ID!
  isLiked: Boolean!
  like: MylistRegistration
  nicovideoSources: [NicovideoVideoSource!]!
  registeredAt: DateTime!
  semitags(checked: Boolean): [Semitag!]!
  serial: Int!
  similarVideos(input: VideoSimilarVideosInput!): VideoSimilarVideosPayload!
  soundcloudSources: [SoundcloudMADSource!]!
  taggings(after: String, before: String, first: Int, last: Int, orderBy: VideoTaggingsOrderBy! = {createdAt: DESC}): VideoTagConnection!
  thumbnailUrl(size: VideoThumbnailScale! = LARGE): String!
  thumbnails: [VideoThumbnail!]!
  title: String!
  titles: [VideoTitle!]!
  youtubeSources: [YoutubeVideoSource!]!
}

type VideoConnection {
  edges: [VideoEdge!]!
  nodes: [Video!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type VideoEdge {
  cursor: String!
  node: Video!
}

interface VideoEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  video: Video!
}

type VideoEventsConnection {
  nodes: [VideoEvent!]!
}

input VideoEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

"""Videoを追加した際に発生．（初回のみ）"""
type VideoRegisterEvent implements Event & Node & VideoEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  video: Video!
}

type VideoSearchItemByTitle {
  title: VideoTitle!
  video: Video!
}

input VideoSimilarVideosInput {
  limit: Int! = 10
}

type VideoSimilarVideosPayload {
  items: [VideoSimilarity!]!
}

type VideoSimilarity {
  origin: Video!
  score: Float!
  to: Video!
}

interface VideoSource {
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type VideoTag {
  events(input: VideoTagEventsInput!): VideoTagEventsConnection!
  id: ID!
  tag: Tag!
  video: Video!
}

type VideoTagAttachEvent implements Event & Node & VideoTagEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTag: VideoTag!
}

type VideoTagConnection {
  edges: [VideoTagEdge!]!
  nodes: [VideoTag!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type VideoTagDetachEvent implements Event & Node & VideoTagEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTag: VideoTag!
}

type VideoTagEdge {
  cursor: String!
  node: VideoTag!
}

interface VideoTagEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTag: VideoTag!
}

type VideoTagEventsConnection {
  nodes: [VideoTagEvent!]!
}

input VideoTagEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type VideoTagReattachEvent implements Event & Node & VideoTagEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTag: VideoTag!
}

input VideoTaggingsOrderBy {
  createdAt: SortOrder
}

type VideoThumbnail {
  events(input: VideoThumbnailEventsInput!): VideoThumbnailEventsConnection!
  id: ID!
  imageUrl: String!
  primary: Boolean!
  video: Video!
}

type VideoThumbnailCreateEvent implements Event & Node & VideoThumbnailEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoThumbnail: VideoThumbnail!
}

interface VideoThumbnailEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoThumbnail: VideoThumbnail!
}

type VideoThumbnailEventsConnection {
  nodes: [VideoThumbnailEvent!]!
}

input VideoThumbnailEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

enum VideoThumbnailScale {
  """960 x 700"""
  LARGE

  """720 x 400"""
  OGP
}

type VideoThumbnailSetPrimaryEvent implements Event & Node & VideoThumbnailEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoThumbnail: VideoThumbnail!
}

type VideoThumbnailUnsetPrimaryEvent implements Event & Node & VideoThumbnailEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoThumbnail: VideoThumbnail!
}

type VideoTitle {
  events(input: VideoTitleEventsInput!): VideoTitleEventsConnection!
  id: ID!
  primary: Boolean!
  title: String!
  video: Video!
}

type VideoTitleCreateEvent implements Event & Node & VideoTitleEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTitle: VideoTitle!
}

interface VideoTitleEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTitle: VideoTitle!
}

type VideoTitleEventsConnection {
  nodes: [VideoTitleEvent!]!
}

input VideoTitleEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type VideoTitleSetPrimaryEvent implements Event & Node & VideoTitleEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTitle: VideoTitle!
}

type VideoTitleUnsetPrimaryEvent implements Event & Node & VideoTitleEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  user: User!
  videoTitle: VideoTitle!
}

input WatchNotificationsInput {
  notificationIds: [ID!]!
}

union WatchNotificationsReturnUnion = WatchNotificationsSucceededPayload

type WatchNotificationsSucceededPayload {
  notifications: [Notification!]!
}

"""Youtubeの音MADがリクエストされたことを表すタイムラインイベント"""
type YoutubeMadRequestedTimelineEvent implements TimelineEvent {
  createdAt: DateTime!
  event: YoutubeRegistrationRequestRequestEvent!
  request: YoutubeRegistrationRequest!
}

type YoutubeOriginalSource {
  sourceId: String!
  thumbnailUrl: String!
  url: String!
}

type YoutubeRegistrationRequest implements Node & RegistrationRequest {
  checked: Boolean!
  checking: YoutubeRegistrationRequestChecking
  embedUrl: String!
  events(input: YoutubeRegistrationRequestEventsInput!): YoutubeRegistrationRequestEventConnection!
  id: ID!
  originalUrl: String!
  requestedBy: User!
  semitaggings: [YoutubeRegistrationRequestSemitagging!]!
  sourceId: String!
  taggings: [YoutubeRegistrationRequestTagging!]!
  thumbnailUrl: String!
  title: String!
}

"""Youtubeの動画をリクエストを承認した時に発生するイベント"""
type YoutubeRegistrationRequestAcceptEvent implements Event & Node & YoutubeRegistrationRequestEvent {
  createdAt: DateTime!
  id: ID!
  request: YoutubeRegistrationRequest!
  series: String!
  user: User!
}

type YoutubeRegistrationRequestAccepting {
  acceptedBy: User!
  note: String
  request: YoutubeRegistrationRequest!
  video: Video!
}

type YoutubeRegistrationRequestAcceptingNotification implements Node & Notification {
  accepting: YoutubeRegistrationRequestAccepting!
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  watched: Boolean!
}

union YoutubeRegistrationRequestChecking = YoutubeRegistrationRequestAccepting | YoutubeRegistrationRequestRejecting

type YoutubeRegistrationRequestConnection {
  edges: [YoutubeRegistrationRequestEdge!]!
  nodes: [YoutubeRegistrationRequest!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type YoutubeRegistrationRequestEdge {
  cursor: String!
  node: YoutubeRegistrationRequest!
}

"""Youtubeの動画リクエスト関連のイベント"""
interface YoutubeRegistrationRequestEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  request: YoutubeRegistrationRequest!
  series: String!
  user: User!
}

type YoutubeRegistrationRequestEventConnection {
  edges: [YoutubeRegistrationRequestEventEdge!]!
  nodes: [YoutubeRegistrationRequestEvent!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type YoutubeRegistrationRequestEventEdge {
  cursor: String!
  node: YoutubeRegistrationRequestEvent!
}

input YoutubeRegistrationRequestEventsInput {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: YoutubeRegistrationRequestEventsInputOrderBy! = {createdAt: DESC}
}

input YoutubeRegistrationRequestEventsInputOrderBy {
  createdAt: SortOrder
}

"""Youtubeの動画をリクエストを拒否した時に発生するイベント"""
type YoutubeRegistrationRequestRejectEvent implements Event & Node & YoutubeRegistrationRequestEvent {
  createdAt: DateTime!
  id: ID!
  request: YoutubeRegistrationRequest!
  series: String!
  user: User!
}

type YoutubeRegistrationRequestRejecting {
  note: String
  rejectedBy: User!
  request: YoutubeRegistrationRequest!
}

type YoutubeRegistrationRequestRejectingNotification implements Node & Notification {
  createdAt: DateTime!
  id: ID!
  notifyTo: User!
  rejecting: YoutubeRegistrationRequestRejecting!
  watched: Boolean!
}

"""Youtubeの動画をリクエスト時に発生するイベント"""
type YoutubeRegistrationRequestRequestEvent implements Event & Node & YoutubeRegistrationRequestEvent {
  createdAt: DateTime!
  id: ID!
  request: YoutubeRegistrationRequest!
  series: String!
  user: User!
}

type YoutubeRegistrationRequestSemitagging implements Node & RegistrationRequestSemitagging {
  id: ID!
  name: String!
  note: String
}

type YoutubeRegistrationRequestTagging implements Node & RegistrationRequestTagging {
  id: ID!
  note: String
  tag: Tag!
}

type YoutubeVideoSource implements Node & VideoSource {
  embedUrl: String!
  events(after: String, before: String, first: Int, last: Int, orderBy: YoutubeVideoSourceEventsOrderBy!): YoutubeVideoSourceEventConnection!
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type YoutubeVideoSourceCreateEvent implements Event & Node & YoutubeVideoSourceEvent {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: YoutubeVideoSource!
  user: User!
}

interface YoutubeVideoSourceEvent implements Event & Node {
  createdAt: DateTime!
  id: ID!
  series: String!
  source: YoutubeVideoSource!
  user: User!
}

type YoutubeVideoSourceEventConnection {
  edges: [YoutubeVideoSourceEventEdge!]!
  nodes: [YoutubeVideoSourceEvent!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type YoutubeVideoSourceEventEdge {
  cursor: String!
  node: YoutubeVideoSourceEvent!
}

input YoutubeVideoSourceEventsOrderBy {
  createdAt: SortOrder
}

input findUncheckedNicovideoRegistrationRequestsByOffsetInput {
  orderBy: findUncheckedNicovideoRegistrationRequestsByOffsetOrderBy! = {createdAt: DESC}
  skip: Int! = 0
  take: Int! = 20
}

input findUncheckedNicovideoRegistrationRequestsByOffsetOrderBy {
  createdAt: SortOrder
}
