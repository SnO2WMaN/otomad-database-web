input AddMylistToMylistGroupInput {
  groupId: ID!
  mylistId: ID!
}

type AddMylistToMylistGroupPayload {
  inclusion: MylistGroupMylistInclusion!
}

enum AddSemitagToVideoFailedMessage {
  """すでに同名の仮タグが付いている"""
  ALREADY_ATTACHED

  """すでにこの仮タグはチェックした"""
  ALREADY_CHECKED
  FORBIDDEN
  INVALID_VIDEO_ID
  UNKNOWN
  VIDEO_NOT_FOUND
}

type AddSemitagToVideoFailedPayload {
  message: AddSemitagToVideoFailedMessage!
}

input AddSemitagToVideoInput {
  name: String!
  videoId: ID!
}

union AddSemitagToVideoPayload = AddSemitagToVideoFailedPayload | AddSemitagToVideoSucceededPayload

type AddSemitagToVideoSucceededPayload {
  semitag: Semitag!
}

enum AddTagToVideoFailedMessage {
  FORBIDDEN
  INVALID_TAG_ID
  INVALID_VIDEO_ID

  """原因不明のエラー"""
  UNKNOWN
  VIDEO_ALREADY_TAGGED
}

type AddTagToVideoFailedPayload {
  message: AddTagToVideoFailedMessage!
}

input AddTagToVideoInput {
  tagId: ID!
  videoId: ID!
}

union AddTagToVideoPayload = AddTagToVideoFailedPayload | AddTagToVideoSucceededPayload

type AddTagToVideoSucceededPayload {
  tag: Tag!
  video: Video!
}

input AddVideoToMylistInput {
  mylistId: ID!
  note: String
  videoId: ID!
}

type AddVideoToMylistPayload {
  registration: MylistRegistration!
}

input CreateMylistGroupInput {
  title: String!
}

type CreateMylistGroupPayload {
  group: MylistGroup!
}

input CreateMylistInput {
  range: MylistShareRange!
  title: String!
}

type CreateMylistPayload {
  mylist: Mylist!
}

scalar DateTime

input FetchNicovideoInput {
  """ニコニコ動画の動画ID（sm2057168など）"""
  sourceId: String!
}

type FetchNicovideoPayload {
  source: NicovideoOriginalSource
}

input FindMylistInput {
  id: ID
}

input FindNicovideoVideoSourceInput {
  sourceId: String
}

input FindSemitagsInput {
  except: [ID!]! = []
  limit: Int! = 10
  order: FindSemitagsInputOrder! = {updatedAt: DESC}
  resolved: Boolean
  skip: Int! = 0
}

input FindSemitagsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input FindTagInput {
  id: ID
  serial: Int
}

input FindTagsInput {
  limit: Int! = 10

  """正確に一致"""
  name: String
  order: FindTagsInputOrder! = {updatedAt: DESC}
  parents: [ID!]
  skip: Int! = 0
}

input FindTagsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input FindUserInput {
  name: String
}

input FindVideoInput {
  id: ID
  serial: Int
}

input FindVideosInput {
  limit: Int! = 10
  order: FindVideosInputOrder! = {createdAt: DESC}
  skip: Int! = 0
}

input FindVideosInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

enum LikeVideoFailedMessage {
  FORBIDDEN
  INVALID_VIDEO_ID
  UNKNOWN
  VIDEO_ALREADY_LIKED
  VIDEO_NOT_FOUND
}

type LikeVideoFailedPayload {
  message: LikeVideoFailedMessage!
}

input LikeVideoInput {
  videoId: ID!
}

union LikeVideoPayload = LikeVideoFailedPayload | LikeVideoSucceededPayload

type LikeVideoSucceededPayload {
  registration: MylistRegistration!
}

type Mutation {
  addMylistToMylistGroup(input: AddMylistToMylistGroupInput!): AddMylistToMylistGroupPayload!
  addSemitagToVideo(input: AddSemitagToVideoInput!): AddSemitagToVideoPayload!
  addTagToVideo(input: AddTagToVideoInput!): AddTagToVideoPayload!
  addVideoToMylist(input: AddVideoToMylistInput!): AddVideoToMylistPayload!
  createMylist(input: CreateMylistInput!): CreateMylistPayload!
  createMylistGroup(input: CreateMylistGroupInput!): CreateMylistGroupPayload!
  likeVideo(input: LikeVideoInput!): LikeVideoPayload!
  registerTag(input: RegisterTagInput!): RegisterTagPayload!
  registerVideo(input: RegisterVideoInput!): RegisterVideoPayload!
  rejectSemitag(input: RejectSemitagInput!): RejectSemitagPayload!
  removeTagFromVideo(input: RemoveTagFromVideoInput!): RemoveTagFromVideoPayload!
  removeVideoFromMylist(input: RemoveVideoFromMylistInput!): RemoveVideoFromMylistPayload!
  resovleSemitag(input: ResolveSemitagInput!): ResolveSemitagPayload!
  signin(input: SigninInput!): SigninPayload!
  signout: SignoutPayload!
  signup(input: SignupInput!): SignupPayload!
  undoLikeVideo(input: UndoLikeVideoInput!): UndoLikeVideoPayload!
}

type Mylist implements Node {
  createdAt: DateTime!
  holder: User!
  id: ID!
  includeTags(input: MylistIncludeTagsInput!): MylistIncludeTagsPayload!

  """マイリストの中にビデオが追加されているか．"""
  isIncludesVideo(id: ID!): Boolean!
  isLikeList: Boolean!
  range: MylistShareRange!
  recommendedVideos(input: MylistRecommendedVideosInput!): MylistRecommendedVideosPayload!
  registrations(input: MylistRegistrationsInput!): MylistRegistrationConnection!
  title: String!
  updatedAt: DateTime!
}

type MylistConnection {
  nodes: [Mylist!]!
}

type MylistGroup implements Node {
  createdAt: DateTime!
  holder: User!
  id: ID!
  mylists(input: MylistGroupMylistsInput!): MylistGroupMylistInclusionConnection!
  title: String!
  updatedAt: DateTime!
  videos(input: MylistGroupVideosInput!): [MylistGroupVideoAggregation!]!
}

type MylistGroupMylistInclusion implements Node {
  createdAt: DateTime!
  group: MylistGroup!
  id: ID!
  mylist: Mylist!
  updatedAt: DateTime!
}

type MylistGroupMylistInclusionConnection {
  nodes: [MylistGroupMylistInclusion!]!
}

input MylistGroupMylistsInput {
  limit: Int! = 10
  order: MylistGroupMylistsInputOrder! = {createdAt: DESC}
  skip: Int! = 0
}

input MylistGroupMylistsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

type MylistGroupVideoAggregation {
  """動画を含んでいるマイリストの数"""
  count: Int!

  """動画を含んでいるマイリスト"""
  mylists(input: MylistGroupVideoAggregationMylistsInput!): [Mylist!]!
  video: Video!
}

input MylistGroupVideoAggregationMylistsInput {
  limit: Int! = 10
  order: MylistGroupVideoAggregationMylistsInputOrder! = {createdAt: DESC}
  skip: Int! = 0
}

input MylistGroupVideoAggregationMylistsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input MylistGroupVideosInput {
  limit: Int! = 10
  order: MylistGroupVideosInputOrder! = {count: DESC}
  skip: Int! = 0
}

input MylistGroupVideosInputOrder {
  count: SortOrder!
}

input MylistIncludeTagsInput {
  limit: Int! = 10
  order: MylistIncludeTagsInputOrder! = {count: DESC}
  skip: Int! = 0
}

input MylistIncludeTagsInputOrder {
  count: SortOrder!
}

type MylistIncludeTagsPayload {
  items: [MylistTagInclusion!]!
}

input MylistRecommendedVideosInput {
  limit: Int! = 10
}

type MylistRecommendedVideosPayload {
  items: [MylistVideoRecommendation!]!
}

type MylistRegistration implements Node {
  createdAt: DateTime!
  id: ID!
  mylist: Mylist!
  note: String
  updatedAt: DateTime!
  video: Video!
}

type MylistRegistrationConnection {
  nodes: [MylistRegistration!]!
}

input MylistRegistrationsInput {
  limit: Int! = 10
  order: MylistRegistrationsInputOrder! = {}
  skip: Int! = 0
}

input MylistRegistrationsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

enum MylistShareRange {
  KNOW_LINK
  PRIVATE
  PUBLIC
}

type MylistTagInclusion {
  count: Int!
  mylist: Mylist!
  tag: Tag!
}

type MylistVideoRecommendation {
  origin: Mylist!
  score: Float!
  to: Video!
}

type NicovideoOriginalSource {
  countComments: Int!
  countLikes: Int!
  countMylists: Int!
  countViews: Int!

  """動画の長さ"""
  duration: Int!
  registeredAt: DateTime!
  sourceId: String!
  tags: [NicovideoOriginalSourceTag!]!
  thumbnailUrl: String!
  title: String!
}

type NicovideoOriginalSourceTag {
  name: String!
  searchTags(input: NicovideoOriginalSourceTagSearchTagsInput!): NicovideoOriginalSourceTagSearchTagsPayload!
}

input NicovideoOriginalSourceTagSearchTagsInput {
  limit: Int! = 3
  skip: Int! = 0
}

type NicovideoOriginalSourceTagSearchTagsItem {
  tag: Tag!
}

type NicovideoOriginalSourceTagSearchTagsPayload {
  items: [NicovideoOriginalSourceTagSearchTagsItem!]!
}

type NicovideoVideoSource implements Node & VideoSource {
  events(input: NicovideoVideoSourceEventsInput!): NicovideoVideoSourceEventConnection!
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type NicovideoVideoSourceCreateEvent implements NicovideoVideoSourceEvent & Node {
  createdAt: DateTime!
  id: ID!
  source: NicovideoVideoSource!
  user: User!
}

interface NicovideoVideoSourceEvent implements Node {
  createdAt: DateTime!
  id: ID!
  source: NicovideoVideoSource!
  user: User!
}

type NicovideoVideoSourceEventConnection {
  nodes: [NicovideoVideoSourceEvent!]!
}

input NicovideoVideoSourceEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

interface Node {
  id: ID!
}

enum PseudoTagType {
  """キャラクター"""
  CHARACTER

  """動画の内容に依らない情報，分類など"""
  CLASS

  """作品名"""
  COPYRIGHT

  """合作などのイベント"""
  EVENT

  """曲"""
  MUSIC

  """特徴的なセリフなど"""
  PHRASE

  """シリーズ"""
  SERIES

  """動画そのものに対しての性質，作風など"""
  STYLE

  """2つ以上のタイプが算出された場合"""
  SUBTLE

  """戦法"""
  TACTICS

  """タイプを算出できなかった場合"""
  UNKNOWN
}

type Query {
  """ニコニコ動画から動画情報を取得する"""
  fetchNicovideo(input: FetchNicovideoInput!): FetchNicovideoPayload!
  findMylist(input: FindMylistInput!): Mylist
  findNicovideoVideoSource(input: FindNicovideoVideoSourceInput!): NicovideoVideoSource
  findSemitags(input: FindSemitagsInput!): SemitagConnection!
  findTag(input: FindTagInput!): Tag
  findTags(input: FindTagsInput!): TagConnection!
  findUser(input: FindUserInput!): User
  findVideo(input: FindVideoInput!): Video
  findVideos(input: FindVideosInput!): VideoConnection!
  mylist(id: ID!): Mylist!
  mylistGroup(id: ID!): MylistGroup!
  nicovideoVideoSource(id: ID!): NicovideoVideoSource!
  searchTags(input: SearchTagInput!): SearchTagsPayload!
  searchVideos(input: SearchVideoInput!): SearchVideosPayload!
  semitag(id: ID!): Semitag!
  tag(id: ID!): Tag!
  user(id: ID!): User!
  video(id: ID!): Video!
  whoami: User
}

enum RegisterTagFailedMessage {
  FORBIDDEN
  INVALID_TAG_ID
  UNKNOWN
}

type RegisterTagFailedPayload {
  message: RegisterTagFailedMessage!
}

input RegisterTagInput {
  explicitParent: ID
  extraNames: [String!]! = []
  implicitParents: [ID!]! = []
  meaningless: Boolean! = false
  primaryName: String!
  resolveSemitags: [ID!]! = []
}

union RegisterTagPayload = RegisterTagFailedPayload | RegisterTagSucceededPayload

type RegisterTagSucceededPayload {
  tag: Tag!
}

enum RegisterVideoFailedMessage {
  FORBIDDEN
  INVALID_NICOVIDEO_SOURCE_ID
  INVALID_TAG_ID
  UNKNOWN
}

type RegisterVideoFailedPayload {
  message: RegisterVideoFailedMessage!
}

input RegisterVideoInput {
  extraTitles: [String!]! = []
  primaryThumbnail: String!
  primaryTitle: String!
  semitags: [String!]! = []
  sources: [RegisterVideoInputSource!]!
  tags: [ID!]!
}

input RegisterVideoInputSource {
  sourceId: String!
  type: RegisterVideoInputSourceType!
}

enum RegisterVideoInputSourceType {
  NICOVIDEO
}

union RegisterVideoPayload = RegisterVideoFailedPayload | RegisterVideoSucceededPayload

type RegisterVideoSucceededPayload {
  video: Video!
}

enum RejectSemitagFailedMessage {
  """権限なし"""
  FORBIDDEN
  INVALID_SEMITAG_ID
  SEMITAG_ALREADY_CHECKED
  SEMITAG_NOT_FOUND

  """原因不明のエラー"""
  UNKNOWN
}

type RejectSemitagFailedPayload {
  message: RejectSemitagFailedMessage!
}

input RejectSemitagInput {
  id: ID!
}

union RejectSemitagPayload = RejectSemitagFailedPayload | RejectSemitagSucceededPayload

type RejectSemitagSucceededPayload {
  semitag: Semitag!
}

enum RemoveTagFromVideoFailedMessage {
  FORBIDDEN
  INVALID_TAG_ID
  INVALID_VIDEO_ID
  NO_TAGGING
  TAGGING_ALREADY_REMOVED
  TAG_NOT_FOUND

  """原因不明のエラー"""
  UNKNOWN
  VIDEO_NOT_FOUND
}

type RemoveTagFromVideoFailedPayload {
  message: RemoveTagFromVideoFailedMessage!
}

input RemoveTagFromVideoInput {
  tagId: ID!
  videoId: ID!
}

union RemoveTagFromVideoPayload = RemoveTagFromVideoFailedPayload | RemoveTagFromVideoSucceededPayload

type RemoveTagFromVideoSucceededPayload {
  tag: Tag!
  video: Video!
}

input RemoveVideoFromMylistInput {
  mylistId: ID!
  videoId: ID!
}

type RemoveVideoFromMylistPayload {
  mylist: Mylist!
  video: Video!
}

enum ResolveSemitagFailedMessage {
  """権限なし"""
  FORBIDDEN
  INVALID_SEMITAG_ID
  INVALID_TAG_ID
  SEMITAG_ALREADY_CHECKED
  SEMITAG_NOT_FOUND
  TAG_NOT_FOUND

  """原因不明のエラー"""
  UNKNOWN
  VIDEO_ALREADY_TAGGED
}

type ResolveSemitagFailedPayload {
  message: ResolveSemitagFailedMessage!
}

input ResolveSemitagInput {
  id: ID!
  tagId: ID!
}

union ResolveSemitagPayload = ResolveSemitagFailedPayload | ResolveSemitagSucceededPayload

type ResolveSemitagSucceededPayload {
  semitag: Semitag!
}

input SearchTagInput {
  limit: Int! = 10
  query: String!
  skip: Int! = 0
}

type SearchTagsItem {
  matchedName: String!
  tag: Tag!
}

type SearchTagsPayload {
  items: [SearchTagsItem!]!
}

input SearchVideoInput {
  limit: Int! = 10
  query: String!
  skip: Int! = 0
}

type SearchVideosItem {
  matchedTitle: String!
  video: Video!
}

type SearchVideosPayload {
  items: [SearchVideosItem!]!
}

type Semitag implements Node {
  events(input: SemitagEventsInput!): SemitagEventConnection!
  id: ID!
  name: String!
  resolved: Boolean!
  resolvedTag: Tag
  video: Video!
}

type SemitagConnection {
  nodes: [Semitag!]!
}

interface SemitagEvent {
  createdAt: DateTime!
  id: ID!
  semitag: Semitag!
  user: User!
}

type SemitagEventAttachEvent implements Node & SemitagEvent {
  createdAt: DateTime!
  id: ID!
  semitag: Semitag!
  user: User!
}

type SemitagEventConnection {
  nodes: [SemitagEvent!]!
}

type SemitagEventRejectEvent implements Node & SemitagEvent {
  createdAt: DateTime!
  id: ID!
  semitag: Semitag!
  user: User!
}

type SemitagEventResolveEvent implements Node & SemitagEvent {
  createdAt: DateTime!
  id: ID!
  semitag: Semitag!
  user: User!
}

input SemitagEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type Session {
  createdAt: DateTime!
  expired: Boolean!
  expiredAt: DateTime!
  id: ID!
  user: User!
}

enum SigninFailedMessage {
  """原因不明のエラー"""
  UNKNOWN

  """ユーザーは存在しない"""
  USER_NOT_FOUND

  """パスワードが間違っている"""
  WRONG_PASSWORD
}

type SigninFailedPayload {
  message: SigninFailedMessage!
}

input SigninInput {
  password: String!
  username: String!
}

union SigninPayload = SigninFailedPayload | SigninSucceededPayload

type SigninSucceededPayload {
  user: User!
}

enum SignoutFailedMessage {
  """セッションIDが取得できない"""
  NO_SESSION_ID

  """セッションが存在しない"""
  SESSION_NOT_FOUND

  """原因不明のエラー"""
  UNKNOWN
}

type SignoutFailedPayload {
  message: SignoutFailedMessage!
}

union SignoutPayload = SignoutFailedPayload | SignoutSucceededPayload

type SignoutSucceededPayload {
  session: Session!
}

enum SignupFailedMessage {
  """そのメールアドレスはすでに存在する"""
  EXISTS_EMAIL

  """そのユーザーネームはすでに存在する"""
  EXISTS_USERNAME

  """原因不明のエラー"""
  UNKNOWN
}

type SignupFailedPayload {
  message: SignupFailedMessage!
}

input SignupInput {
  displayName: String!
  email: String!
  name: String!
  password: String!
}

union SignupPayload = SignupFailedPayload | SignupSucceededPayload

type SignupSucceededPayload {
  user: User!
}

enum SortOrder {
  ASC
  DESC
}

type Tag implements Node {
  """動画に対してタグを付けることができるか"""
  canTagTo(
    """動画のID"""
    videoId: ID!
  ): Boolean!
  explicitParent: Tag
  id: ID!
  meaningless: Boolean!
  name: String!
  names: [TagName!]!
  parents(meaningless: Boolean): [TagParent!]!
  pseudoType: PseudoTagType!
  serial: Int!
  taggedVideos: [Video!]!
  type: TagType! @deprecated
}

type TagConnection {
  nodes: [Tag!]!
}

type TagName {
  name: String!
  primary: Boolean!
}

type TagParent {
  explicit: Boolean!
  tag: Tag!
}

enum TagType {
  CLASS
  COPYRIGHT
  EVENT
  IMAGE
  MATERIAL
  MUSIC
  SERIES
  TACTICS
}

enum UndoLikeVideoFailedMessage {
  FORBIDDEN
  INVALID_VIDEO_ID
  UNKNOWN
  VIDEO_NOT_FOUND
  VIDEO_NOT_LIKED
}

type UndoLikeVideoFailedPayload {
  message: UndoLikeVideoFailedMessage!
}

input UndoLikeVideoInput {
  videoId: ID!
}

union UndoLikeVideoPayload = UndoLikeVideoFailedPayload | UndoLikeVideoSucceededPayload

type UndoLikeVideoSucceededPayload {
  mylist: Mylist!
  video: Video!
}

type User implements Node {
  displayName: String!
  icon: String
  id: ID!
  isAdministrator: Boolean!
  isEditor: Boolean!
  likes: Mylist
  mylist(id: ID!): Mylist
  mylists(input: UserMylistsInput!): MylistConnection!
  name: String!
}

input UserMylistsInput {
  limit: Int! = 10
  order: UserMylistsInputOrder! = {createdAt: ASC}
  range: [MylistShareRange!]! = [PUBLIC]
  skip: Int! = 0
}

input UserMylistsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

type Video implements Node {
  events(input: VideoEventsInput!): VideoEventsConnection!
  hasTag(id: ID!): Boolean!
  id: ID!
  nicovideoSources: [NicovideoVideoSource!]!
  registeredAt: DateTime!
  semitags(resolved: Boolean): [Semitag!]!
  serial: Int!
  similarVideos(input: VideoSimilarVideosInput!): VideoSimilarVideosPayload!
  tags(input: VideoTagsInput!): [VideoTag!]!
  thumbnailUrl: String!
  thumbnails: [VideoThumbnail!]!
  title: String!
  titles: [VideoTitle!]!
}

type VideoConnection {
  nodes: [Video!]!
}

interface VideoEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  video: Video!
}

type VideoEventsConnection {
  nodes: [VideoEvent!]!
}

input VideoEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

"""Videoを追加した際に発生．（初回のみ）"""
type VideoRegisterEvent implements VideoEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  video: Video!
}

input VideoSimilarVideosInput {
  limit: Int! = 10
}

type VideoSimilarVideosPayload {
  items: [VideoSimilarity!]!
}

type VideoSimilarity {
  origin: Video!
  score: Float!
  to: Video!
}

interface VideoSource {
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type VideoTag {
  events(input: VideoTagEventsInput!): VideoTagEventsConnection!
  id: ID!
  tag: Tag!
  video: Video!
}

type VideoTagAttachEvent implements Node & VideoTagEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoTag: VideoTag!
}

type VideoTagDetachEvent implements Node & VideoTagEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoTag: VideoTag!
}

interface VideoTagEvent implements Node {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoTag: VideoTag!
}

type VideoTagEventsConnection {
  nodes: [VideoTagEvent!]!
}

input VideoTagEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type VideoTagReattachEvent implements Node & VideoTagEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoTag: VideoTag!
}

input VideoTagsInput {
  """未指定なら全てを取得する"""
  limit: Int
  order: VideoTagsInputOrder! = {updatedAt: DESC}
  skip: Int! = 0
}

input VideoTagsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

type VideoThumbnail {
  events(input: VideoThumbnailEventsInput!): VideoThumbnailEventsConnection!
  id: ID!
  imageUrl: String!
  primary: Boolean!
  video: Video!
}

type VideoThumbnailCreateEvent implements Node & VideoThumbnailEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoThumbnail: VideoThumbnail!
}

interface VideoThumbnailEvent implements Node {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoThumbnail: VideoThumbnail!
}

type VideoThumbnailEventsConnection {
  nodes: [VideoThumbnailEvent!]!
}

input VideoThumbnailEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type VideoThumbnailSetPrimaryEvent implements Node & VideoThumbnailEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoThumbnail: VideoThumbnail!
}

type VideoThumbnailUnsetPrimaryEvent implements Node & VideoThumbnailEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoThumbnail: VideoThumbnail!
}

type VideoTitle {
  events(input: VideoTitleEventsInput!): VideoTitleEventsConnection!
  id: ID!
  primary: Boolean!
  title: String!
  video: Video!
}

type VideoTitleCreateEvent implements Node & VideoTitleEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoTitle: VideoTitle!
}

interface VideoTitleEvent implements Node {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoTitle: VideoTitle!
}

type VideoTitleEventsConnection {
  nodes: [VideoTitleEvent!]!
}

input VideoTitleEventsInput {
  limit: Int! = 10
  skip: Int! = 0
}

type VideoTitleSetPrimaryEvent implements Node & VideoTitleEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoTitle: VideoTitle!
}

type VideoTitleUnsetPrimaryEvent implements Node & VideoTitleEvent {
  createdAt: DateTime!
  id: ID!
  user: User!
  videoTitle: VideoTitle!
}

type YoutubeVideoSource implements Node & VideoSource {
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}