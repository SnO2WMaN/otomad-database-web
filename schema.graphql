input AddVideoToMylistInput {
  mylistId: ID!
  note: String
  videoId: ID!
}

type AddVideoToMylistPayload {
  registration: MylistRegistration!
}

input CreateMylistInput {
  range: MylistShareRange!
  title: String!
}

type CreateMylistPayload {
  mylist: Mylist!
}

scalar DateTime

input FindMylistInput {
  id: ID
}

input FindNicovideoVideoSourceInput {
  sourceId: String
}

input FindTagsInput {
  limit: Int! = 10
  order: FindTagsInputOrder! = {updatedAt: DESC}
  skip: Int! = 0
}

input FindTagsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input FindUserInput {
  name: String
}

input FindVideosInput {
  limit: Int! = 10
  order: FindVideosInputOrder! = {createdAt: DESC}
  skip: Int! = 0
}

input FindVideosInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input LikeVideoInput {
  videoId: ID!
}

type LikeVideoPayload {
  registration: MylistRegistration!
}

type Mutation {
  addVideoToMylist(input: AddVideoToMylistInput!): AddVideoToMylistPayload!
  createMylist(input: CreateMylistInput!): CreateMylistPayload!
  likeVideo(input: LikeVideoInput!): LikeVideoPayload!
  registerTag(input: RegisterTagInput!): RegisterTagPayload!
  registerVideo(input: RegisterVideoInput!): RegisterVideoPayload!
  removeVideoFromMylist(input: RemoveVideoFromMylistInput!): RemoveVideoFromMylistPayload!
  resovleSemitag(input: ResolveSemitagInput!): ResolveSemitagPayload!
  tagVideo(input: TagVideoInput!): TagVideoPayload!
  undoLikeVideo(input: UndoLikeVideoInput!): UndoLikeVideoPayload!
  untagVideo(input: UntagVideoInput!): UntagVideoPayload!
}

type Mylist implements Node {
  createdAt: DateTime!
  holder: User!
  id: ID!
  includeTags(input: MylistIncludeTagsInput!): MylistIncludeTagsPayload!

  """マイリストの中にビデオが追加されているか．"""
  isIncludesVideo(id: ID!): Boolean!
  isLikeList: Boolean!
  range: MylistShareRange!
  recommendedVideos(input: MylistRecommendedVideosInput!): MylistRecommendedVideosPayload!
  registrations(input: MylistRegistrationsInput!): MylistRegistrationCollection!
  title: String!
  updatedAt: DateTime!
}

input MylistIncludeTagsInput {
  limit: Int! = 10
}

type MylistIncludeTagsItem {
  count: Int!
  tag: Tag!
}

type MylistIncludeTagsPayload {
  items: [MylistIncludeTagsItem!]!
}

input MylistRecommendedVideosInput {
  limit: Int! = 10
}

type MylistRecommendedVideosItem {
  score: Float!
  video: Video!
}

type MylistRecommendedVideosPayload {
  items: [MylistRecommendedVideosItem!]!
}

type MylistRegistration implements Node {
  createdAt: DateTime!
  id: ID!
  mylist: Mylist!
  note: String
  updatedAt: DateTime!
  video: Video!
}

type MylistRegistrationCollection {
  nodes: [MylistRegistration!]!
}

input MylistRegistrationsInput {
  limit: Int
  order: MylistRegistrationsInputOrder! = {}
  skip: Int
}

input MylistRegistrationsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

enum MylistShareRange {
  KNOW_LINK
  PRIVATE
  PUBLIC
}

type MylistsConnection {
  nodes: [Mylist!]!
}

type NicovideoVideoSource implements Node & VideoSource {
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

interface Node {
  id: ID!
}

enum PseudoTagType {
  """キャラクター"""
  CHARACTER

  """動画の内容に依らない情報，分類など"""
  CLASS

  """作品名"""
  COPYRIGHT

  """合作などのイベント"""
  EVENT

  """曲"""
  MUSIC

  """特徴的なセリフなど"""
  PHRASE

  """シリーズ"""
  SERIES

  """動画そのものに対しての性質，作風など"""
  STYLE

  """2つ以上のタイプが算出された場合"""
  SUBTLE

  """戦法"""
  TACTICS

  """タイプを算出できなかった場合"""
  UNKNOWN
}

type Query {
  findMylist(input: FindMylistInput!): Mylist
  findNicovideoVideoSource(input: FindNicovideoVideoSourceInput!): NicovideoVideoSource
  findTags(input: FindTagsInput!): TagCollection!
  findUser(input: FindUserInput!): User
  findVideos(input: FindVideosInput!): VideoCollection!
  mylist(id: ID!): Mylist!
  nicovideoVideoSource(id: ID!): NicovideoVideoSource!
  searchTags(input: SearchTagInput!): SearchTagsPayload!
  searchVideos(input: SearchVideoInput!): SearchVideosPayload!
  semitag(id: ID!): Semitag!
  tag(id: ID!): Tag!
  user(id: ID!): User!
  video(id: ID!): Video!
  whoami: User
}

input RegisterTagInput {
  explicitParent: ID
  extraNames: [String!]! = []
  implicitParents: [ID!]! = []
  meaningless: Boolean! = false
  primaryName: String!
}

type RegisterTagPayload {
  tag: Tag!
}

input RegisterVideoInput {
  extraTitles: [String!]! = []
  primaryThumbnail: String!
  primaryTitle: String!
  semitags: [String!]! = []
  sources: [RegisterVideoInputSource!]!
  tags: [ID!]!
}

input RegisterVideoInputSource {
  sourceId: String!
  type: RegisterVideoInputSourceType!
}

enum RegisterVideoInputSourceType {
  NICOVIDEO
}

type RegisterVideoPayload {
  video: Video!
}

input RemoveVideoFromMylistInput {
  mylistId: ID!
  videoId: ID!
}

type RemoveVideoFromMylistPayload {
  mylist: Mylist!
  video: Video!
}

input ResolveSemitagInput {
  id: ID!
  tagId: ID
}

type ResolveSemitagPayload {
  semitag: Semitag!
}

input SearchTagInput {
  limit: Int! = 10
  query: String!
  skip: Int! = 0
}

type SearchTagsItem {
  matchedName: String!
  tag: Tag!
}

type SearchTagsPayload {
  items: [SearchTagsItem!]!
}

input SearchVideoInput {
  limit: Int! = 10
  query: String!
  skip: Int! = 0
}

type SearchVideosItem {
  matchedTitle: String!
  video: Video!
}

type SearchVideosPayload {
  items: [SearchVideosItem!]!
}

type Semitag implements Node {
  id: ID!
  name: String!
  resolved: Boolean!
  resolvedTag: Tag
  video: Video!
}

enum SortOrder {
  ASC
  DESC
}

type Tag implements Node {
  """動画に対してタグを付けることができるか"""
  canTagTo(
    """動画のID"""
    videoId: ID!
  ): Boolean!
  explicitParent: Tag
  history(input: TagHistoryInput!): TagHistoryCollection!
  id: ID!
  meaningless: Boolean!
  name: String!
  names: [TagName!]!
  parents(meaningless: Boolean): [TagParent!]!
  pseudoType: PseudoTagType!
  taggedVideos: [Video!]!
  type: TagType! @deprecated
}

type TagAddNameHistoryItem implements TagHistoryItem {
  createdAt: DateTime!
  id: ID!
  name: String!
  tag: Tag!
  user: User!
}

type TagChangePrimaryNameHistoryItem implements TagHistoryItem {
  createdAt: DateTime!
  from: String
  id: ID!
  tag: Tag!
  to: String!
  user: User!
}

type TagCollection {
  nodes: [Tag!]!
}

type TagDeleteNameHistoryItem implements TagHistoryItem {
  createdAt: DateTime!
  id: ID!
  name: String!
  tag: Tag!
  user: User!
}

type TagHistoryCollection {
  nodes: [VideoHistoryItem!]!
}

input TagHistoryInput {
  limit: Int! = 10
  order: TagHistoryOrder! = {createdAt: DESC}
  skip: Int! = 0
}

interface TagHistoryItem {
  createdAt: DateTime!
  id: ID!
  user: User!
}

input TagHistoryOrder {
  createdAt: SortOrder
}

type TagName {
  name: String!
  primary: Boolean!
}

type TagParent {
  explicit: Boolean!
  tag: Tag!
}

type TagRegisterHistoryItem implements TagHistoryItem {
  createdAt: DateTime!
  id: ID!
  tag: Tag!
  user: User!
}

enum TagType {
  CLASS
  COPYRIGHT
  EVENT
  IMAGE
  MATERIAL
  MUSIC
  SERIES
  TACTICS
}

input TagVideoInput {
  tagId: ID!
  videoId: ID!
}

type TagVideoPayload {
  tag: Tag!
  video: Video!
}

input UndoLikeVideoInput {
  videoId: ID!
}

type UndoLikeVideoPayload {
  mylist: Mylist!
  video: Video!
}

input UntagVideoInput {
  tagId: ID!
  videoId: ID!
}

type UntagVideoPayload {
  tag: Tag!
  video: Video!
}

type User implements Node {
  displayName: String!
  favorites: Mylist!
  icon: String!
  id: ID!
  mylists(input: UserMylistsInput!): MylistsConnection!
  name: String!
}

input UserMylistsInput {
  limit: Int! = 10
  order: UserMylistsInputOrder! = {createdAt: ASC}
  range: [MylistShareRange!]! = [PUBLIC]
  skip: Int! = 0
}

input UserMylistsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

type Video implements Node {
  hasTag(id: ID!): Boolean!
  history(input: VideoHistoryInput!): VideoHistoryCollection!
  id: ID!
  nicovideoSources: [NicovideoVideoSource!]!
  registeredAt: DateTime!
  semitags(resolved: Boolean): [Semitag!]!
  similarVideos(input: VideoSimilarVideosInput!): VideoSimilarVideosPayload!
  tags: [Tag!]!
  thumbnailUrl: String!
  thumbnails: [VideoThumbnail!]!
  title: String!
  titles: [VideoTitle!]!
}

type VideoAddNicovideoVideoSourceHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  id: ID!
  source: NicovideoVideoSource!
  user: User!
  video: Video!
}

type VideoAddTagHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  id: ID!
  tag: Tag!
  user: User!
  video: Video!
}

type VideoAddThumbnailHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  id: ID!
  thumbnail: String!
  user: User!
  video: Video!
}

type VideoAddTitleHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  id: ID!
  title: String!
  user: User!
  video: Video!
}

type VideoChangePrimaryThumbnailHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  from: String
  id: ID!
  to: String!
  user: User!
  video: Video!
}

type VideoChangePrimaryTitleHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  from: String
  id: ID!
  to: String!
  user: User!
  video: Video!
}

type VideoCollection {
  nodes: [Video!]!
}

type VideoDeleteTagHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  id: ID!
  tag: Tag!
  user: User!
  video: Video!
}

type VideoDeleteThumbnailHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  id: ID!
  thumbnail: String!
  user: User!
  video: Video!
}

type VideoDeleteTitleHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  id: ID!
  title: String!
  user: User!
  video: Video!
}

type VideoHistoryCollection {
  nodes: [VideoHistoryItem!]!
}

input VideoHistoryInput {
  limit: Int! = 10
  order: VideoHistoryOrder! = {createdAt: DESC}
  skip: Int! = 0
}

interface VideoHistoryItem {
  createdAt: DateTime!
  id: ID!
  user: User!
  video: Video!
}

input VideoHistoryOrder {
  createdAt: SortOrder
}

type VideoRegisterHistoryItem implements VideoHistoryItem {
  createdAt: DateTime!
  id: ID!
  user: User!
  video: Video!
}

type VideoSimilarVideoItem {
  score: Float!
  video: Video!
}

input VideoSimilarVideosInput {
  limit: Int! = 10
}

type VideoSimilarVideosPayload {
  items: [VideoSimilarVideoItem!]!
}

interface VideoSource {
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}

type VideoThumbnail {
  imageUrl: String!
  primary: Boolean!
}

type VideoTitle {
  primary: Boolean!
  title: String!
}

type YoutubeVideoSource implements Node & VideoSource {
  id: ID!
  sourceId: String!
  url: String!
  video: Video!
}